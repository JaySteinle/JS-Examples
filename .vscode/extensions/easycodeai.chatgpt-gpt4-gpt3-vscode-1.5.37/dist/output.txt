// src/extension.ts

        vscode.window
          .showInputBox({
            prompt: "Please describe the error and desired behaviour",
            placeHolder:
              "Array out of bound error, why is this not showing up? etc.",
          })
          .then((value) => {
            if (value === undefined) {
              return;
            }

            legacyWebviewViewProvider.getMixPanel()?.track("Fix Bug", {
              distinct_id: legacyWebviewViewProvider.getMachineId(),
              prompt: value,
            });
            newWebviewViewProvider.postMessage({
              type: "contextMenuOptionSelected",
              data: {
                option: "ask",
                input: value,
                selectedText:
                  vscode.window.activeTextEditor?.document.getText(selection),
              },
            });
            vscode.commands.executeCommand("easycode.chatView.focus");
          });
      }
// src/chat/agents/defaultAskCodebaseAgent.ts

            }

            /*
            if (selectedCodebaseContent?.queryType){
                agent = queryTypeToAgentMap[selectedCodebaseContent.queryType];
                if (agent.type == ChatAgentType.codebaseImplementation){
                    [ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
                } else {
                [ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
                }
            } else {
                agent = new CodebaseImplementationAgent();
                [ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
            }
            console.log(userMessage.content?.substring(userMessage.content.length - 15));
            */
        }
// src/extension.ts

              }
              console.log(fullResponse);
            }
          });
      }
    ),
    vscode.commands.registerCommand(
      "easycode.fixBug",
      (_uri?: vscode.Uri, range?: vscode.Range) => {
// src/chat/agents/defaultAskCodebaseAgent.ts

        }
    }
}

export default DefaultAskCodebaseAgent;
// src/extension.ts

      (_uri?: vscode.Uri, range?: vscode.Range) => {
        Sentry.addBreadcrumb({
          category: "vscode command",
          message: "fixBug",
          level: "info",
        });

        const selection = range ?? vscode.window.activeTextEditor?.selection;
        if (selection === undefined) {
          return;
        }

        vscode.window
// src/chat/agents/defaultAskCodebaseAgent.ts

export class DefaultAskCodebaseAgent extends BaseAgent {

    public selectedCodebaseContent: SelectedCodebaseContent | null;
    constructor(
        {
            type = ChatAgentType.askCodebase,
            systemMessage = "You are an AI coding assistant. You will be provided file and code snippets, and answer the user's request.",
            firstMessagePromptPre = "Based on the code and files above, ",
            firstMessagePromptPost = ". Reference files and code.",
            followUpMessagePromptPre = "",
            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = true,
            llmChatHistory = [],
            selectedCodebaseContent = null,
            functions = undefined,
        }: Partial<DefaultAskCodebaseAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, functions})
        this.selectedCodebaseContent = selectedCodebaseContent;
    }

    public override async createUserMessageFromLastUserOrAgentMessage(messages: EasyCodeChatMessage[], model: string){
// src/extension.ts

    vscode.commands.registerCommand(
      "easycode.ask",
      (_uri?: vscode.Uri, range?: vscode.Range) => {
        Sentry.addBreadcrumb({
          category: "vscode command",
          message: "ask",
          level: "info",
        });

        //console.log("easycode.ask");
        //postMessage({ command: 'contextMenuOptionSelected', data: _uri});

        const selection = range ?? vscode.window.activeTextEditor?.selection;
        if (selection === undefined) {
          return;
        }

        vscode.window
// src/extension.ts

          .then((value) => {
            if (value === undefined) {
              return;
            }

            legacyWebviewViewProvider.getMixPanel()?.track("Ask EasyCode", {
              distinct_id: legacyWebviewViewProvider.getMachineId(),
              prompt: value,
            });
            newWebviewViewProvider.postMessage({
              type: "contextMenuOptionSelected",
              data: {
                option: "ask",
                input: value,
                selectedText:
                  vscode.window.activeTextEditor?.document.getText(selection),
              },
            });
            vscode.commands.executeCommand("easycode.chatView.focus");
            //provider.getWebView()?.webview.postMessage({ type: 'switchOrAddNewTab', tabIndex: provider.getMessageHistory().length});
            //provider.ask(value, undefined, true, false, false, selection);
          });
// src/webview/pages/components/ChatTab.tsx

                ];
                // Check the state of isAskCodebase and provide the appropriate suggestions
                const suggestions = askCodebaseCommands;
                return { suggestions: suggestions };
              },
// src/chat/agents/defaultAskCodebaseAgent.ts

            } else {
                if (this.shouldRetrieveInFollowUps){
                    let selectedCodebaseContent = await Globals.getEasyCodeClient().getCodebaseContentForInput({input: input, model: model, maxChunks: 5, generateQuestions: false, queryType: queryType});
                    if (selectedCodebaseContent == undefined){
                        throw Error("no codebase content retrieved");
                    }
                    this.selectedCodebaseContent = selectedCodebaseContent;
                    this.llmChatHistory[1].content = userAtSelectionString + selectedCodebaseContent.selectedAllCodeContext + this.llmChatHistory[1].content;
                }
                input = this.followUpMessagePromptPre + input + this.followUpMessagePromptPost;
                let lastUserOrAgentMessage: AgentLLMChatMessage = {
                    role: 'user',
                    content: input
                };
                this.llmChatHistory.push(lastUserOrAgentMessage);
            }
// src/chat/agents/defaultAskCodebaseAgent.ts

import { EasyCodeClient, SelectedCodebaseContent } from "../../apis/extensionToServerApi";
import { OpenAIClient } from "../../apis/openaiClient";
import { Globals } from "../../config/globals";
import { extractPromptFilesAndMethods } from "../../helpers/utils";
import { appendFileSkeletonContent } from "../../modules/fileSkeleton";
import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage, EasyCodeChatMessage } from "../../types/chatMessage"
import BaseAgent from "./baseAgent";

export class DefaultAskCodebaseAgent extends BaseAgent {
// src/webview/pages/components/ChatTab.tsx

                            Codebase Implementation
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.codebaseTwoStepImplementation && (
                          <>
                            <IoCodeWorkingOutline className="w-5 h-5 mr-2" />
                            Codebase Implementation
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.codebaseTwoStepPlanning && (
                          <>
                            <IoLogoElectron className="w-5 h-5 mr-2" />
                            Codebase Planning
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.codebaseExplain && (
                          <>
// src/webview/pages/components/ChatTab.tsx

                          <>
                            <IoSunnyOutline className="w-5 h-5 mr-2" />
                            Codebase Explain
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.askCodebase && (
                          <>
                            <IoSunnyOutline className="w-5 h-5 mr-2" />
                            Ask Codebase
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.default && (
                          <>
// src/webviewProvider/reactWebviewViewProvider.ts

    } else if (isAskCodebase == true) {
      getMixPanel()?.track("Ask Codebase", {
        distinct_id: legacyWebviewViewProvider.getMachineId(),
        ...createPropertiesFromLongText(content, "prompt"),
      });

      if (chatObj.type == ChatType.uninitialized) {
// src/webview/pages/components/ChatTab.tsx

              <div className="w-full flex flex-row">
                <Checkbox
                  className="pl-1 mr-0 flex-shrink-0"
                  isSelected={isAskCodebase}
                  onChange={handleAskCodebaseChange}
                >
                  Ask Codebase
                </Checkbox>
                {isAskCodebase && isCodebaseRefreshVisible && !isDisabled && (
                  <HoverTooltip content="Refresh Codebase Index">
                    <Button
                      isIconOnly
                      className="flex-shrink-0 bg-transparent"
                      onPress={handleRefreshCodebaseIndex}
                    >
                      <IoSyncOutline className="w-6 h-6 pl-0 ml-0 mr-2 mt-0 hover:text-blue-500" />
                    </Button>
                  </HoverTooltip>
                )}
                <Checkbox
                  className="mr-2 flex-shrink-0"
                  isSelected={isAskWeb}
                  onChange={handleAskWebChange}
                >
                  Ask Web
                </Checkbox>
// src/webviewProvider/reactWebviewViewProvider.ts

          }
        } else {
          const promptIntent = await easyCodeClient.classifyPromptIntent({
            prompt: content,
          });
          if (promptIntent == "code implementation") {
            getMixPanel()?.track("Codebase Implementation", {
              distinct_id: legacyWebviewViewProvider.getMachineId(),
              ...createPropertiesFromLongText(content, "prompt"),
            });
            chat = new TwoStepCodebasePlanningAndImplementationChat({
              title: content,
            });
          } else if (promptIntent == "code explain") {
            getMixPanel()?.track("Codebase Explain", {
              distinct_id: legacyWebviewViewProvider.getMachineId(),
              ...createPropertiesFromLongText(content, "prompt"),
            });
            chat = new CodebaseExplainChat({ title: content });
          } else {
            chat = new AskCodebaseChat({ title: content });
          }
        }
// src/webview/pages/components/ChatTab.tsx

                          <>
                            <IoCodeWorkingOutline className="w-5 h-5 mr-2" />
                            Diff GPT
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.codebaseDiffImplementation && (
                          <>
                            <IoCodeWorkingOutline className="w-5 h-5 mr-2" />
                            Codebase Diff Implementation
                          </>
                        )}
                        {easyCodeChatMessage.easyCodeMetadata?.agentType ==
                          ChatAgentType.codebaseImplementation && (
                          <>
                            <IoCodeWorkingOutline className="w-5 h-5 mr-2" />
                            Codebase Implementation
// src/config/globals.ts

export class Globals {

    static _easyCodeClient: EasyCodeClient;
    static _openAIClient: OpenAIClient;

    static _settings: ExtensionSettings = {
        selectedInsideCodeblock: false,
        copyOnClick: true,
        maxTokens: 500,
        temperature: 0,
        model: 'gpt-3.5-turbo',
        userEmail: '',
        openAIApiKey: '',
        inlineCompletion: true,
        dataCollection: true,
        usePromptAssistant: true,
        useOwnApiKey: false,
        useActiveViewContext: false
    };

    static getSettings() {
        return this._settings;
    }

    static setSettings(newSettings: ExtensionSettings) {
        this._settings = {...this._settings, ...newSettings};
    }

    static getEasyCodeClient() {
        return this._easyCodeClient;
    }

    static setEasyCodeClient(newEasyCodeClient: EasyCodeClient) {
        this._easyCodeClient = newEasyCodeClient;
    }

    static getOpenAIClient() {
        return this._openAIClient;
    }

    static setOpenAIClient(newOpenAIClient: OpenAIClient) {
// src/chat/agents/codebaseTwoStepPlanningAgent.ts

            shouldRetrieveInFollowUps = true,
            llmChatHistory = [],
            selectedCodebaseContent = null
        }: Partial<DefaultAskCodebaseAgent> = {}
// src/webviewProvider/reactWebviewViewProvider.ts

        if (selectedCodebaseContent) {
          let closestCodeChunkOrFileSummary =
            await easyCodeClient.findClosestCodebaseChunkOrFileSummary({
              text,
              selectedCodebaseContent,
            });
          if (closestCodeChunkOrFileSummary) {
// src/chat/agents/codebaseTwoStepPerFileImplementationAgent.ts

            } else {
                let followUpSelectedCodebaseContent = await Globals.getEasyCodeClient().getCodebaseContentForInput({input: userMessage.content, model: model ? model : 'gpt-4-1106-preview', maxChunks: 5, generateQuestions: false, queryType: "code implementation"});

                if (followUpSelectedCodebaseContent){
// src/config/globals.ts

import { EasyCodeClient } from "../apis/extensionToServerApi";
import { OpenAIClient } from "../apis/openaiClient";
import { ExtensionSettings } from "../types/types";

export class Globals {
// src/webviewProvider/reactWebviewViewProvider.ts

    /*
		let encodedResponseLength = encodeString(easyCodeChatMessage.content ? easyCodeChatMessage.content : '').length;

		if (useOwnApiKey == true){
			if (model == 'gpt-4' || model == 'gpt-4-1106-preview'){
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-4 Output Tokens Used', encodedResponseLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-4 Output Cost ($0.06/1000 tokens)', (encodedResponseLength / 1000) * 0.06);
			} else {
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-3.5 Output Tokens Used', encodedResponseLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-3.5 Output Cost ($0.002/1000 tokens)', (encodedResponseLength / 1000) * 0.002);
			}
		} else {
			if (model == 'gpt-4' || model == 'gpt-4-1106-preview'){
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-4 Output Tokens Used', encodedResponseLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-4 Output Cost ($0.06/1000 tokens)', (encodedResponseLength / 1000) * 0.06);
			} else {
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-3.5 Output Tokens Used', encodedResponseLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-3.5 Output Cost ($0.002/1000 tokens)', (encodedResponseLength / 1000) * 0.002);
			}
		}*/
// src/webviewProvider/reactWebviewViewProvider.ts

    if (isAskWeb == true) {
      getMixPanel()?.track("Ask Web", {
        distinct_id: legacyWebviewViewProvider.getMachineId(),
        ...createPropertiesFromLongText(content, "prompt"),
      });
      if (chatObj.type == ChatType.uninitialized) {
        chat = new AskWebChat({ title: content });
      } else {
        chat = new AskWebChat(chatObj);
      }
    } else if (isAskCodebase == true) {
// src/chat/agents/codebaseDiffPerFileImplementationAgent.ts

            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = false,
            llmChatHistory = [],
            selectedCodebaseContent = null,
            functions = [search_and_replace_schema_next_file]
        }: Partial<DefaultAskCodebaseAgent> = {}
// src/apis/extensionToServerApi.ts

        try {
          ask_codebase_response = await client.post(
            "/ask-codebase/",
            getFormData
          );
        } catch (error: any) {
          if (error.response.status == 429) {
            throw new Error(
              "You have reached the rate limit for free usage of ask codebase. Please upgrade your plan."
            );
          } else if (error.response.status == 405) {
            throw new Error(
              "You cannot use free GPT-4 for ask codebase. Please purchase GPT-4 credits."
            );
          }
          return;
        }

        //console.log(ask_codebase_response.data);
        let closest_chunk_root_identifiers: string[] =
          ask_codebase_response.data.closest_chunk_root_identifiers;
        let closest_chunk_file_names: string[] =
          ask_codebase_response.data.closest_chunk_file_names;
        let closest_chunk_file_index: string[] =
          ask_codebase_response.data.closest_chunk_file_index;
        let closest_chunk_file_sizes =
// src/chat/chats/twoStepCodebasePlanningAndImplementationChat.ts

                }
            }

            try {
                await getCodeDiff();
            }  catch(error){
                if (error == 'No matches found!'){
                    console.log('No matches found. Attempting to self-correct.');
                    await getCodeDiff();
                }
            }
        }
// src/chat/agents/codebasePerFileImplementationAgent.ts

            selectedCodebaseContent = null,
        }: Partial<DefaultAskCodebaseAgent> = {}
    )  {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, selectedCodebaseContent});
    }
// src/config/globals.ts

    static setOpenAIClient(newOpenAIClient: OpenAIClient) {
        this._openAIClient = newOpenAIClient;
    }
}
// src/chat/agents/codebaseTwoStepPlanningAgent.ts

export class CodebaseTwoStepPlanningAgent extends DefaultAskCodebaseAgent {

    constructor(
        {
            type = ChatAgentType.codebaseTwoStepPlanning,
            systemMessage = "You are a codebase implementation planner for a new feature. You will be provided existing files and code snippets, and provide an initial implementation plan. The plan should be organized into file-by-file implementation steps. The steps should be ordered based on data flow. Ignore files that do not require changing, and do not show any code. After providing the initial implementation plan, you will switch into plan revision mode. In this mode, I will provide you instructions, and you will create a revised plan incorporating my instructions.",
            firstMessagePromptPre = "Create a file-by-file implementation plan for this feature request: ",
            firstMessagePromptPost = ". Ignore files that don't require changing. Do not show code.",
            followUpMessagePromptPre = "Return a revised implementation plan based on these instructions: ",
            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = true,
// src/webview/components/EditorContextMenuListener.tsx

        case 'fixIssue':
          console.log(message.data);
          dispatch(webviewToExtensionApi.endpoints.addTab.initiate()).then(result => {
            if ('data' in result){
              let newTabId = result?.data.newTabId;
              dispatch(inputText.actions.setInputText({text: 'Code Context:\n\n' + message.data.codeContext + '\n\nErroring Text:\n\n' + message.data.errorTextPortion + '\n\nError Message:\n\n' + message.data.errorMessage, tabId: newTabId}));
            }
          })
          break;
      }
// src/chat/chats/twoStepCodebasePlanningAndImplementationChat.ts

                    try {

                        let ai_response = undefined;
                        if (aiResponse){
                            ai_response = aiResponse;
                        }
                        aiResponse = "";

                        for await (let streamingAIResponse of Globals.getEasyCodeClient().generateCodeDiff({source_code: implementationCodingPhase.fileContents[0], instruction: lastPhaseMessage, ai_response: ai_response})) {
// src/modules/codeActionsProvider.ts

import vscode, { CodeAction, CodeActionProvider, CodeActionKind, Diagnostic, Range, TextDocument, CodeActionContext, CancellationToken, Command } from "vscode";

const isCodeActionsEnabled = (): boolean => (
    vscode.workspace.getConfiguration('easycode').get<boolean>('codeActions', true)
);

export class EasyCodeActionsProvider implements CodeActionProvider {
// src/chat/agents/codebaseTwoStepPlanningAgent.ts

import { EasyCodeClient } from "../../apis/extensionToServerApi";
import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage, EasyCodeChatMessage } from "../../types/chatMessage";
import BaseAgent from "./baseAgent";
import DefaultAskCodebaseAgent from "./defaultAskCodebaseAgent";


export class CodebaseTwoStepPlanningAgent extends DefaultAskCodebaseAgent {
// src/chat/chats/twoStepCodebasePlanningAndImplementationChat.ts

                        } catch (error: any) {
                            if (error == 'STOPSIGNAL'){
                                this.processMessageIntoFilePaths(streamingMessage?.content, this.selectedCodebaseContent, true);
                                /*
                                let codebasePlanningAgent = this.phases[0];
                                for await (let { message, messageIndex } of codebasePlanningAgent.submitChatMessage('Implementation for current step:\n\n' + this.aiImplementationResponse, 'gpt-4-1106-preview')) {
                                    if (message.role == 'assistant' && !message.content.includes('<')){
                                        this.aiImplementationPlan = message.content;
                                    }
                                }*/
                            }
                            throw error;
                        }
// src/chat/chats/twoStepCodebasePlanningAndImplementationChat.ts

            }
        }
    }
}

export default TwoStepCodebasePlanningAndImplementationChat;
// src/chat/agents/codebaseTwoStepPlanningAgent.ts

        }: Partial<DefaultAskCodebaseAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, selectedCodebaseContent})
    }
// src/chat/phases/basePhase.ts

		}*/
		// first respond with the user's content

		console.log(model);

		//console.log(messages[1].content?.substring(messages[1].content.length - 15));
		//console.log(messages[1].content);

		let easyCodeChatMessage: EasyCodeChatMessage = {
            role: 'assistant',
            content: '',
        }

        easyCodeChatMessage['easyCodeMetadata'] = {model, isAskCodebase: false, isAskWeb: false, selectedCodebaseContent: undefined};

		let maxLoops = 10;
		let currentLoop = 0;
		while(currentLoop < maxLoops && this.agentIterationsLeft > 0){
// src/modules/codeActionsProvider.ts

export class EasyCodeActionsProvider implements CodeActionProvider {
    public static readonly providedCodeActionKinds = [
        CodeActionKind.QuickFix
    ];

    public provideCodeActions(document: TextDocument, range: Range | vscode.Selection, context: CodeActionContext, token: CancellationToken): vscode.ProviderResult<CodeAction[]> {
        if (!isCodeActionsEnabled()) {
            return null;
        }

        // Filter out diagnostics that are not within the range specified
        const diagnostics = context.diagnostics.filter(diagnostic => range.intersection(diagnostic.range) !== undefined);

        if (diagnostics.length === 0) {
            return [];
        }

        const actions: CodeAction[] = diagnostics.map(diagnostic => this.createCodeAction(document, diagnostic));

        return actions;
    }

    private createCodeAction(document: TextDocument, diagnostic: Diagnostic): CodeAction {
// src/sentry/react-webview-telemetry.ts

        // Set tracesSampleRate to 0.01 to capture 1%
        // of transactions for performance monitoring.
        tracesSampleRate: 0.01,

        // Set `tracePropagationTargets` to control for which URLs distributed tracing should be enabled
        tracePropagationTargets: [
          easycode_url,
          // inline completion endpoint
          '209.20.159.29',
        ],

        // Capture Replay for 0.1% of all sessions,
        // plus for 100% of sessions with an error
        replaysSessionSampleRate: 0.001,
        replaysOnErrorSampleRate: 1.0,
      });
// src/chat/agents/codebaseTwoStepPerFileImplementationAgent.ts

                }
            }
        }
    }
}

export default CodebaseTwoStepPerFileImplementationAgent;
// src/modules/indexCodebase.ts

        });
    }
}

async function getEasyCodeIgnorePatterns(workspaceFolder: vscode.WorkspaceFolder){

    const ignoreFilePath = path.join(workspaceFolder.uri.fsPath, '.vscode', 'easycode.ignore');
    const ignoreFileUri = vscode.Uri.file(ignoreFilePath);

    try {
        await vscode.workspace.fs.stat(ignoreFileUri);
    } catch {
        // The file does not exist, create it
        const defaultIgnoreList = [
            "node_modules/",
            "dist/",
            "vendor/",
            "cache/",
            ".*/",
            "*.min.*",
            "*.test.*",
            "*.spec.*",
            "*.bundle.*",
            "*.bundle-min.*",
            "*.*.js",
            "*.*.ts",
            "*.log"
        ];

        const defaultIgnoreContent = defaultIgnoreList.join('\n');

        const encodedContent = new TextEncoder().encode(defaultIgnoreContent);
        await vscode.workspace.fs.writeFile(ignoreFileUri, encodedContent);
    }

    // Now the file should exist, read it
    const content = await vscode.workspace.fs.readFile(ignoreFileUri);
    const decodedContent = new TextDecoder().decode(content);
// src/chat/chats/twoStepCodebasePlanningAndImplementationChat.ts

            /*
            let fileUri;
            if (!this.selectedCodebaseContent){
                throw("Selected Codebase Content Not Found");
            }
            for (let i = 0; i < this.selectedCodebaseContent.selectedChunkFileNames.length; i++){
                let selectedChunkFilePath = this.selectedCodebaseContent.selectedChunkFileNames[i];
                if (selectedChunkFilePath.includes(filePath)){
                    fileUri = vscode.Uri.joinPath(vscode.Uri.file(this.selectedCodebaseContent.selectedChunkRootIdentifiers[i]), selectedChunkFilePath);
                    break;
                }
            }
            */

            if (!fileUri){
                throw("File not found for current message");
            }

            const document = await vscode.workspace.openTextDocument(fileUri);

            let editor = await vscode.window.showTextDocument(document);
            let selectionList: any[];
            let newCodeList: any[];

            let aiResponse: string;

            async function getCodeDiff() {
// src/modules/codeActionsProvider.ts

    private createCodeAction(document: TextDocument, diagnostic: Diagnostic): CodeAction {
        const action = new CodeAction(`Fix with EasyCode: ${diagnostic.message}`, CodeActionKind.QuickFix);
        action.diagnostics = [diagnostic];
        action.isPreferred = true;

        // Calculate the expanded range to include three lines above and below the diagnostic's range
        const expandedRange = this.getExpandedRange(document, diagnostic.range);

        // Define the command that the code action will invoke
        const command: Command = {
            title: 'Fix Issue',
            command: 'easycode.fixIssue', // Replace with your actual command
            arguments: [document.uri, diagnostic.range, expandedRange, diagnostic]
        };

        action.command = command;

        return action;
    }

    private getExpandedRange(document: TextDocument, range: Range): Range {
// src/types/types.ts

export type ExtensionSettings = {selectedInsideCodeblock?: boolean, copyOnClick?: boolean, model?: string, maxTokens?: number, temperature?: number, userEmail?: string, openAIApiKey?: string, inlineCompletion?: boolean, dataCollection?: boolean, useOwnApiKey?:boolean, usePromptAssistant?:boolean, useActiveViewContext?:boolean}
// src/chat/chats/diffCodebaseImplementationChat.ts

                                        selectionList.push(selection);
                                        newCodeList.push(indentedCode)
                                    }
                                } catch (error:any) {
                                    if (error == 'No matches found!'){
                                        continue;
                                    } else {
                                        throw error;
                                    }
                                }
// src/modules/indexCodebase.ts

    }
}

export async function openPrimaryGitIgnoreFile(){
    const workspaceFolders = vscode.workspace.workspaceFolders;

    if (workspaceFolders && workspaceFolders[0]) {
        const ignoreFilePath = path.join(workspaceFolders[0].uri.fsPath, '.vscode', 'easycode.ignore');
        const ignoreFileUri = vscode.Uri.file(ignoreFilePath);
        try {
            let document = await vscode.workspace.openTextDocument(ignoreFileUri);
            await vscode.window.showTextDocument(document);
        } catch {
            vscode.window.showErrorMessage("cannot open EasyCode ignore file");
        }
    } else {
        vscode.window.showErrorMessage("Workspace not found");
    }
}
// src/chat/agents/codebaseTwoStepPerFileImplementationAgent.ts

        } else {
            if (userMessage.content.includes("@")){

                const filesAndMethods = extractPromptFilesAndMethods(userMessage.content);

                let fileSkeletonContent = await appendFileSkeletonContent(filesAndMethods?.matches, userMessage.content);


                let userAtSelectionString = '';

                if (fileSkeletonContent) {
                    userAtSelectionString += fileSkeletonContent;
                    userMessage.content = userMessage.content.replace('@', '');
                }

                console.log("======= finalPromptString: =======",userAtSelectionString);
                this.llmChatHistory[1].content = userAtSelectionString + this.llmChatHistory[1].content;
                await super.createUserMessageFromLastUserOrAgentMessage(messages, model);
            } else {
// src/chat/agents/diffAgent.ts

            //systemMessage = "Context Diff Format: \n\n*** ****\noriginal_lines_of_code\n--- ----\nupdated_lines_of_code.\n\nYou are an AI coding assistant that will answer in a context diff format. You will always format your answer as a context diff code block (```). A context diff contains multiple hunks, where each hunk will contain original_lines_of_code from the source code that need to be replaced with updated_lines_of_code. You must follow these rules when when creating each hunk:\n\n-original_lines_of_code must not be empty. Fill it with the full lines of code from the source code that needs to be replaced.\n-Be very careful when writing the diff. Your changes should not accidentally break or remove existing lines. You can reprint existing lines at the bottom or top of the updated lines.\n-original_lines_of_code is continguous and must be copied exactly from the source code, without any altering or adjustments.\n-The hunk cannot contain code abbreviations or pseudocode like (//), (...), (// ...rest of), (// ...existing), (// ...other), you must return actual lines of code.\n\nAlways format your code blocks as a context diff with multiple hunks of this format:\n\n*** ****\noriginal_lines_of_code\n--- ----\nupdated_lines_of_code.",
            systemMessage = "You are a brilliant and meticulous engineer assigned to write code to complete the user's request. When you write code, the code works on the first try, and is complete. Take into account the current repository's language, code style, and dependencies. Your job is to make edits to the file to complete the user request. Your changes should not accidentally break or remove existing lines from old_code. You can reprint existing lines at the bottom or top of the new_code.",
            firstMessagePromptPre = "",
            firstMessagePromptPost = "",
            followUpMessagePromptPre = "",
            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = false,
            llmChatHistory = [],
            functions = [search_and_replace_schema]
        }: Partial<DiffAgent> = {}
// src/chat/chats/codebaseImplementationChat.ts

export class CodebaseImplementationChat extends BaseChat {

    constructor(
        {
            type = ChatType.codebaseImplementation,
            phases = [new CodebaseImplementationPhase()],
            currentPhaseIndex = 0,
            title = '',
            actions = [ChatAction.startNextFileImplementation]
        }: Partial<CodebaseImplementationChat> = {}
    ) {
        super({ type, phases, currentPhaseIndex, title, actions });
    }

    public override async *evokeAction(action: ChatAction){
        if (action == ChatAction.startNextFileImplementation){
            let codebaseImplementationPhase = this.phases[this.currentPhaseIndex] as CodebaseImplementationPhase;

            for await (let { message, messageIndex } of codebaseImplementationPhase.submitChatMessage("continue", "gpt-4-1106-preview", true)) {
                yield { message, messageIndex };
            }
        }
    }

}

export default CodebaseImplementationChat;
// src/chat/agents/codebasePerFileImplementationAgent.ts

    }
}

export default CodebasePerFileImplementationAgent;
// src/apis/extensionToServerApi.ts

export type EasyCodeUser = {
  id: number;
  userEmail?: string;
  subscribed?: boolean;
  subscribedCodebase?: boolean;
  role?: string;
  isPlaceholderAccount?: boolean;
  gpt4TokensTotal?: number;
  gpt4TokensUsed?: number;
};

export type SelectedCodebaseContent = {
  selectedAllCodeContext: string;
  selectedAllFileSummaries: string;
  selectedChunkRootIdentifiers: string[];
  selectedChunkFileNames: string[];
  selectedChunkFileIndex: string[];
  selectedChunkCode: string[];
  selectedChunkFileSummaries: string[];
  queryType?: string;
};

export type ClosestCodeChunkOrFileSummary = {
  closestChunkRootIdentifier: string;
  closestChunkFileName: string;
  closestChunkFileIndex: string;
  isFileSummary: boolean;
};

let abortAllActiveStreams = true;

export type EasyCodeClientApi = {
// src/chat/agents/codebaseExplainAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage } from "../../types/chatMessage";
import BaseAgent from "./baseAgent";
import DefaultAskCodebaseAgent from "./defaultAskCodebaseAgent";


export class CodebaseExplainAgent extends DefaultAskCodebaseAgent {
// src/chat/agents/codebaseExplainAgent.ts

export class CodebaseExplainAgent extends DefaultAskCodebaseAgent {

    constructor(
        {
        type = ChatAgentType.codebaseExplain,
        systemMessage = "You are an expert developer who will explain how a codebase works by looking at files and code snippets. You will reference files when explaining.",
        firstMessagePromptPre = "Based on the code and files above, ",
        firstMessagePromptPost = ". Reference files and code.",
        followUpMessagePromptPre = "\n\nHere are some more files and code. ",
        followUpMessagePromptPost = "",
        shouldRetrieveInFollowUps = true,
        llmChatHistory = []
        } : Partial<BaseAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory})

    }
}

export default CodebaseExplainAgent;
// src/chat/agents/codebaseDiffPerFileImplementationAgent.ts

export class CodebaseDiffPerFileImplementationAgent extends DefaultAskCodebaseAgent {

    constructor(
        {
            type = ChatAgentType.codebaseDiffImplementation,
            systemMessage = "You are a brilliant and meticulous engineer assigned to write code to complete the user's request. You will be provided existing files and source code snippets and you will implement across multiple files in the codebase. When you write code, the code works on the first try, and is complete. Take into account the current repository's language, code style, and dependencies. Your job is to make edits to the file to complete the user request. Your changes should not accidentally break or remove existing lines from old_code. You can reprint existing lines at the bottom or top of the new_code.",
            firstMessagePromptPre = "",
            firstMessagePromptPost = "\n\nMakes changes to 1 file in each message, and determine the next_file to work on. If all changes are complete, set next_file to ''. Ignore files that do not require changing.",
            followUpMessagePromptPre = "",
            followUpMessagePromptPost = "",
// src/apis/extensionToServerApi.ts

              /* TODO fix this
                provider.getWebView()?.webview.postMessage({ type: 'populatePromptIdeas', isAskCodebase: true, codebasePromptIdeas: codebasePromptIdeas});
                */
              resolve();
            } else {
// src/chat/agents/codebaseTwoStepPerFileImplementationAgent.ts

        followUpMessagePromptPost = "\n\nAt the end of your response, either list file paths for the files you will work on next, or state that you have finished coding the entire implementation.",
        shouldRetrieveInFollowUps = true,
        llmChatHistory = [],
        selectedCodebaseContent,
        }: Partial<BaseAgent> & {selectedCodebaseContent: SelectedCodebaseContent}
// src/chat/agents/function_schemas/function_schemas.ts

        },
        required: ["file_name", "analysis_and_identification", "replaces_to_make"],
    },
    description: "Make edits to the code file.",
}
// src/apis/openaiClient.ts

                        /*
                        if (isAskCodebase && isAskCodebase == true) {
                            this.getMixPanel()?.track('Answered Ask Codebase', {
                                distinct_id: this.getMachineId(),
                                useOwnApiKey,
                            });
                        }

                        let encodedResponse = enc.encode(response);
                        if (model == 'gpt-4'){
                            this.getMixPanel()?.people.increment(this.getMachineId(), 'User API Key GPT-4 Output Tokens Used', encodedResponse.length);
                            this.getMixPanel()?.people.increment(this.getMachineId(), 'User API Key GPT-4 Output Cost ($0.06/1000 tokens)', (encodedResponse.length / 1000) * 0.06);
                        } else {
                            this.getMixPanel()?.people.increment(this.getMachineId(), 'User API Key GPT-3.5 Output Tokens Used', encodedResponse.length);
                            this.getMixPanel()?.people.increment(this.getMachineId(), 'User API Key GPT-3.5 Output Cost ($0.002/1000 tokens)', (encodedResponse.length / 1000) * 0.002);
                        }

                        */
// src/chat/agents/codebasePerFileImplementationAgent.ts

export class CodebasePerFileImplementationAgent extends DefaultAskCodebaseAgent {

    constructor(
        {
            type = ChatAgentType.codebaseImplementation,
            systemMessage = "You are a brilliant and meticulous engineer assigned to write code to complete the user's request. You will be provided existing files and source code snippets and you will implement across multiple files in the codebase. When you write code, the code works on the first try, and is complete. Take into account the current repository's language, code style, and dependencies. Your job is to make edits to the file to complete the user request.",
            firstMessagePromptPre = "",
            firstMessagePromptPost = "\n\nShow code changes for 1 file in each message. At the end of each message, either state the next file you will work on, or state that the implementation is complete. Ignore files that do not require changing.",
            followUpMessagePromptPre = "",
            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = false,
            llmChatHistory = [],
            selectedCodebaseContent = null,
// src/chat/phases/askCodebasePhase.ts


import DefaultAskCodebaseAgent from "../agents/defaultAskCodebaseAgent";
import BasePhase from "./basePhase";

export class AskCodebasePhase extends BasePhase {
    constructor(
        {
			agents = [new DefaultAskCodebaseAgent()],
		}: Partial<BasePhase> = {}
    ) {
        super({agents: agents});
    }
}

export default AskCodebasePhase;
// src/modules/generateCommitMessage.ts

export async function generateCommitMessage(easyCodeClient: EasyCodeClient){

    const gitExtension = vscode.extensions.getExtension('vscode.git');

    const git = gitExtension?.exports.getAPI(1);

    let workspaceFolders = vscode.workspace.workspaceFolders;
    if (workspaceFolders){
// src/modules/indexCodebase.ts

        let codebasePromptIdeas = context.workspaceState.get<string>(codebasePromptIdeasKey);
        if (codebasePromptIdeas){
            provider.getWebView()?.webview.postMessage({ type: 'populatePromptIdeas', isAskCodebase: true, codebasePromptIdeas: codebasePromptIdeas});
        } else {
            provider.getWebView()?.webview.postMessage({ type: 'populatePromptIdeas', isAskCodebase: true});
        }
    }
// src/apis/extensionToServerApi.ts

        /*

        if (shouldAskCodebaseSummary && relevant_file_paths && relevant_file_paths.length > 0){
          for (var i = 0; i < relevant_file_paths.length; i++){
            fileSummaries += "//" + relevant_file_paths[i] + "\n\n" + relevant_file_summaries[i] + "\n\n"
          }
        }

        const createPromptPartial = (messageHistory: ChatCompletionRequestMessage[], allCodeContext?: string) => {
          if (shouldAskCodebaseSummary && relevant_file_paths && relevant_file_paths.length > 0){
            return createPrompt(codebaseSummary + fileSummaries + 'Based on the code and files above, ' + input + ", changing the following files: " + relevant_file_paths.join(", ") + ". Show 1 file change per message.", messageHistory, allCodeContext);
          } else {
            return createPrompt(codebaseSummary + fileSummaries  + 'Based on the code and files above, ' + input + selectedText, messageHistory, allCodeContext);
          }
        }

        */

        /*
// src/chat/chats/diffCodebaseImplementationChat.ts

            for await (let { message, messageIndex } of codebaseDiffImplementationPhase.submitChatMessage(content, model, doNotEchoOrStore)){
                if (message.role == 'assistant'){
                    if (message.content){
                        aiResponse = message.content;
                    }
                    let function_call_response = partialParseJson(aiResponse);

                    let current_file = function_call_response.current_file;
                    let diffsList = function_call_response.replaces_to_make;
                    if (current_file && codebaseDiffImplementationAgent.selectedCodebaseContent && !editor && doesMessageContainFilePath(current_file)){
// src/chat/agents/codebaseTwoStepPerFileImplementationAgent.ts

    constructor(
        {
        type = ChatAgentType.codebaseTwoStepImplementation,
        systemMessage = "You are a flexible developer who will code a feature across multiple files. You will be provided an initial implementation plan with steps and files. I will provide you file contents, and you will give me code changes for the provided file(s). New code inside your code blocks should contain existing lines above and below so I can identify the exact spot in the file. If I provide you file contents or instructions that differ from the original plan, you will add these into the implementation plan and your previous implementation code. If I ask you questions, you will answer them. At the end of your code implementation message, you will state which file(s) you will work on next, or state that you have completed coding the entire implementation plan (not just the files I gave you).",
        firstMessagePromptPre = "",
        firstMessagePromptPost = "",
        followUpMessagePromptPre = "",
        followUpMessagePromptPost = "\n\nAt the end of your response, either list file paths for the files you will work on next, or state that you have finished coding the entire implementation.",
// src/webview/redux/uiActions.ts

export const followUpInputText = {
  reducer: followUpInputTextSlice.reducer,
  actions: followUpInputTextSlice.actions,
}

// Export as an object
export const askCodebaseChecked = {
  reducer: askCodebaseCheckboxSlice.reducer,
  actions: askCodebaseCheckboxSlice.actions,
};

// Export as an object
export const askWebChecked = {
  reducer: askWebCheckboxSlice.reducer,
  actions: askWebCheckboxSlice.actions,
};
// src/chat/phases/twoStepCodebaseImplementationPhase.ts

    }

    public async *startImplementationPlan(){
        let agent = this.agents[0];
        let userMessage: EasyCodeChatMessage = {
            role: 'user',
            content: this.implementationPlan
        };
        let aiMessage: EasyCodeChatMessage = {
            role: 'assistant',
            content: 'Ok, let us begin.'
        }
        //This needs to be manually triggered so we can append the additional message afterwards

        await agent.createChatMessages([userMessage]);
        agent.llmChatHistory.push(aiMessage);
        let filePathsAndContents = ''
        for (let filePathIndex = 0; filePathIndex < this.filePaths.length; filePathIndex++){
            let filePath = this.filePaths[filePathIndex];
            let fileContent = this.fileContents[filePathIndex];
            filePathsAndContents = filePathsAndContents + '<Existing File: ' + filePath + '>\n\n' + fileContent + '\n\n</Existing File>\n\n';
        }
        try {
// src/apis/openaiClient.ts

                        /*
                        ((parsedArguments === undefined || !isMessageComplete) ? (
                            Promise.resolve()
                        ) : (
                            this.configCodeEvalHandle(parsedArguments, codeEvalLang).then<void>(async (output) => {
                                if (output !== null) {
                                    this._messageHistory[this._tabIndex].push({
                                        role: 'function',
                                        name: functionCall.name,
                                        content: output,
                                    });
                                    await context.workspaceState.update('chatHistory', this._messageHistory);
                                }
                            })
                        )).then(() => {
                            if (this._sortedMap && this._sortedMap.length > 0){
                                this._view?.webview.postMessage({ type: 'addFollowUpBox', tabIndex: this._tabIndex, codebaseAnswer: true});
                            } else {
                                this._view?.webview.postMessage({ type: 'addFollowUpBox', tabIndex: this._tabIndex});
                            }
                        }).finally(() => {
                            console.log(this._messageHistory[this._tabIndex]);
                        });*/
// src/chat/agents/codebaseDiffPerFileImplementationAgent.ts

        }: Partial<DefaultAskCodebaseAgent> = {}
    )  {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, selectedCodebaseContent, functions});
    }
// src/chat/phases/twoStepCodebaseImplementationPhase.ts

}

export default TwoStepCodebaseImplementationPhase;
// src/apis/extensionToServerApi.ts

        /*
        const codebaseSummaryKey = 'codebaseSummaryKey';
        let codebaseSummary = context.workspaceState.get(codebaseSummaryKey);

        const getFormData2 = () => {
          const formData = new FormData();
          for (let relevantFileSummary of relevantFileSummaries){
            formData.append('file_summaries', relevantFileSummary);
          }
          formData.append('codebase_summary', codebaseSummary);
          formData.append('query', input + selectedText);
          return formData;
        }

        let rerank_file_summaries_response;
        try {
          rerank_file_summaries_response = await client.post('/rerank-file-summaries/', getFormData2);
        } catch(error:any){
          if (error.response.status == 429){
            throw new Error('You have reached the rate limit for free usage of ask codebase. Please upgrade your plan.');
          }
          return;
        };

        let reranker_result_file_indexes = rerank_file_summaries_response.data.rerank_results;
        */
// src/modules/indexCodebase.ts

import * as vscode from 'vscode';

import fs, { ReadStream } from 'node:fs';
import crypto from 'node:crypto';
import path from 'node:path';
import { TextDecoder, TextEncoder, deprecate } from 'node:util';
import child_process from 'node:child_process';
import os from 'node:os';

import * as Sentry from '@sentry/node';
import { ChatCompletionRequestMessage, Configuration, OpenAIApi } from 'openai';
import { get_encoding } from '@dqbd/tiktoken';
import axios from 'axios';
import EventSource from 'eventsource';
import ReconnectingEventSource from 'reconnecting-eventsource';
import * as fglob from 'fast-glob';
import debounce from 'lodash/debounce';
import ignore from 'ignore';
import winston from 'winston';
import LogzioWinstonTransport from 'winston-logzio';
import { v4 as uuidv4 } from 'uuid';
import FormData from 'form-data';
import Mixpanel from 'mixpanel';
import { PythonExtension, PVSC_EXTENSION_ID } from '@vscode/python-extension';
import { addAllFilesToNodeSelectedMap, collectFileNodes, processFilesToNestedStructure } from '../helpers/fileNodeUtils';
// src/webview/redux/uiActions.ts

const followUpInputTextSlice = createSlice({
  name: 'inputText',
  initialState: initialInputTextState,
  reducers: {
    setFollowUpInputText: (state, action: PayloadAction<InputTextPayload>) => {
      state.text = action.payload.text;
      state.tabId = action.payload.tabId;
    },
    // other reducers...
  },
});

const askCodebaseCheckboxSlice = createSlice({
  name: 'askCodebaseCheckbox',
  initialState: false,
  reducers: {
    setAskCodebaseCheckbox: (state, action: PayloadAction<boolean>) => {
      state = action.payload;
    },
    // other reducers...
  },
});

const askWebCheckboxSlice = createSlice({
  name: 'askWebCheckbox',
  initialState: false,
  reducers: {
    setAskCodebaseCheckbox: (state, action: PayloadAction<boolean>) => {
      state = action.payload;
    },
    // other reducers...
  },
});

// Export as an object
export const inputText = {
  reducer: inputTextSlice.reducer,
  actions: inputTextSlice.actions,
};

export const followUpInputText = {
// src/chat/agents/codebaseTwoStepPlanningAgent.ts

    }
}

export default CodebaseTwoStepPlanningAgent;
// src/chat/agents/codebasePerFileImplementationAgent.ts

import { ChatAgentType } from "../../types/agents";
import { DefaultAskCodebaseAgent } from "./defaultAskCodebaseAgent";

export class CodebasePerFileImplementationAgent extends DefaultAskCodebaseAgent {
// src/chat/chats/diffCodebaseImplementationChat.ts

            }
        } catch (error: any) {
            if (error == 'STOPSIGNAL'){

                if (selectionList.length > 0 && newCodeList.length > 0 && editor){

                    if (debouncedCreateOrUpdateDiffView) {
                        debouncedCreateOrUpdateDiffView.flush(); // Assuming you have a flush method on your debounced function
                    }
                    showApplyChangesNotification(editor.document, selectionList, newCodeList);
                }
            }
            throw error;
        }
// src/apis/openaiClient.ts

        }

    }
    return Object.assign(openAIClient, easycodeOpenAIClientApi);
}
// src/chat/agents/baseAgent.ts

        if (useOwnApiKey == true && model != 'claude-instant-1'){
			try {
				for await (const data of Globals.getOpenAIClient().submitChatMessage({ model: model ? model : "gpt-4", messages: this.llmChatHistory})) {
					streamingEasyCodeChatMessage.content += data;
					yield streamingEasyCodeChatMessage;
				}
			} catch (error: any) {
                if (error == 'STOPSIGNAL'){
                    streamingEasyCodeChatMessage['easyCodeMetadata'].finishedStreaming = true;
                    this.llmChatHistory.push(streamingEasyCodeChatMessage);
                }
                throw error;
			}
		} else {
// src/chat/phases/basePhase.ts

import BaseAgent from "../agents/baseAgent";
import CodebaseDiffPerFileImplementationAgent from "../agents/codebaseDiffPerFileImplementationAgent";
import CodebaseExplainAgent from "../agents/codebaseExplainAgent";
import CodebaseTwoStepPlanningAgent from "../agents/codebaseTwoStepPlanningAgent";
import DefaultAgent from "../agents/defaultAgent";
import DefaultAskCodebaseAgent from "../agents/defaultAskCodebaseAgent";
import DiffAgent from "../agents/diffAgent";
import CodebaseTwoStepPerFileImplementationAgent from "../agents/codebaseTwoStepPerFileImplementationAgent";
import ReadFileContentAgent from "../agents/readFileContentAgent";
import { EasyCodeClient, SelectedCodebaseContent } from "../../apis/extensionToServerApi";
import { OpenAIClient } from "../../apis/openaiClient";
import { removeMessageHistoryFromIndex } from "../../helpers/utils";
import { Agent, ChatAgentType } from "../../types/agents";
import { EasyCodeChatMessage, UserAgentChatMessage } from "../../types/chatMessage";
import { ChatPhase, ChatPhaseType } from "../../types/chatPhase";
// src/chat/phases/basePhase.ts

    public async *submitChatMessage(content:string, model:string, doNotEchoOrStore?:boolean) {
		/*
		if (messageIndex == 0 || messageIndex == 1){
			//set messageIndex to 0 as we are restarting
			messageIndex = 0;

			if (isAskWeb == true){
				let allWebScrapedTexts = await easyCodeClient.scrapeWebContentForInput({input: content, model: model});
				//content = allWebScrapedTexts + "\n\n" + "Based on the text above, " + content;
				[ systemMessage, userMessage ] = createPrompt(new AskWebAgent(), content, model, allWebScrapedTexts);
			} else if (isAskCodebase == true){
				getMixPanel()?.track('Ask Codebase', {
					distinct_id: legacyWebviewViewProvider.getMachineId(),
					prompt: origContent
				});
				try {
					selectedCodebaseContent = await easyCodeClient.getCodebaseContentForInput({input: content, model: model, maxChunks: 20, generateQuestions: true});
					if (selectedCodebaseContent?.queryType){
						agent = queryTypeToAgentMap[selectedCodebaseContent.queryType];
						if (agent.type == ChatAgentType.codebaseImplementation){
							[ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
						} else {
						[ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
						}
					} else {
						agent = new CodebaseImplementationAgent();
						[ systemMessage, userMessage ] = createPrompt(agent, content, model, selectedCodebaseContent?.selectedAllCodeContext);
					}
					console.log(userMessage.content?.substring(userMessage.content.length - 15));
				} catch (error: any) {
					await postError(error, { id });
					return;
				}
			} else {
				[ systemMessage, userMessage ] = createPrompt(new DefaultAgent(), content, model);
			}

			systemMessage['easyCodeMetadata'] = {model, isAskCodebase: isAskCodebase || false, isAskWeb: isAskWeb || false, selectedCodebaseContent: selectedCodebaseContent ? selectedCodebaseContent: undefined}

			messageIndex++;
		} else {
			//If this is an ask codebase follow-up, then we need to add more context chunks
			if (isAskCodebase == true){
				let currentConvoAgent = messages[1].easyCodeMetadata?.agent;
				if (currentConvoAgent?.shouldRetrieveInFollowUps){
					selectedCodebaseContent = await easyCodeClient.getCodebaseContentForInput({input: content, model: model, maxChunks: 4});
					if (selectedCodebaseContent){
						let selectedAllCodeContext = selectedCodebaseContent.selectedAllCodeContext;
						messages[1].content = selectedAllCodeContext + '\n\n' + messages[1].content;
						//messages[1].content = selectedAllCodeContext + '\n\n' + messages[1].content;
						if (currentConvoAgent?.shouldRetrieveInFollowUps){
							userMessage = {
								role: 'user',
								content: currentConvoAgent?.followUpMessagePromptPre + content + currentConvoAgent?.followUpMessagePromptPost
							}
						}
						userMessage = {
							role: 'user',
							content: currentConvoAgent?.followUpMessagePromptPre + content + currentConvoAgent?.followUpMessagePromptPost
						}
					} else {
						userMessage = {
							role: 'user',
							content: currentConvoAgent?.followUpMessagePromptPre + content + currentConvoAgent?.followUpMessagePromptPost
						}
					}
				} else {
					userMessage = {
						role: 'user',
						content: currentConvoAgent?.followUpMessagePromptPre + content + currentConvoAgent?.followUpMessagePromptPost
					}
				}
			} else {
				getMixPanel()?.track('Ask Followup', {
					distinct_id: legacyWebviewViewProvider.getMachineId(),
					prompt: origContent
				});

				userMessage = {
					role: 'user',
					content,
				}
			}
		}
		*/
// src/chat/agents/codebaseCallGraphAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import DefaultAskCodebaseAgent from "./defaultAskCodebaseAgent";
import { create_call_graph_schema } from "./function_schemas/function_schemas";


export class CodebaseCallGraphAgent extends DefaultAskCodebaseAgent {
// src/modules/indexCodebase.ts

        let indexPromise = await easyCodeClient?.indexCodebase({file_read_streams, file_paths, workspace_path: rootIdentifier, on_progress: (increment) => {
            totalProgress += increment;
            progress.report({
                increment,
                message: `(${totalProgress.toString()}%)`
            });
        }, force_full_index: force_full_index }
        ).catch(error => {
            vscode.window.showErrorMessage('Indexing Error: ' + error.message);
            throw error; // This will cancel the progress bar
        });

        return indexPromise;
        //return indexCodebaseRootTask(provider, indexRoot, rootIdentifier, )
    });
// src/apis/openaiClient.ts

                        */

                        if (parsedArguments === undefined) {
                            /*
                            this._messageHistory[this._tabIndex].push({
                                role: 'assistant',
                                content: response,
                                easyCodeMetadata: { ...easyCodeMetadata, isMessageComplete },
                            });
                            */
                        } else {
// src/chat/agents/function_schemas/function_schemas.ts

    description: "Make edits to the code file by listing all sections that should receive changes and the changes to be made in each section. Be sure to consider all imports that are required to complete the task.",
}
// src/chat/agents/codebaseCallGraphAgent.ts

export class CodebaseCallGraphAgent extends DefaultAskCodebaseAgent {

    constructor(
        {
        type = ChatAgentType.codebaseCallGraph,
        systemMessage = "You are a call graph generator that will look at files and code snippets and return the call graph of the user's request. Your call graph should include both direct and indirect calls. You will return a list of functions.",
        firstMessagePromptPre = "Based on the code and files above, ",
        firstMessagePromptPost = ". Return a list of functions.",
        followUpMessagePromptPre = "",
        followUpMessagePromptPost = "",
        shouldRetrieveInFollowUps = true,
        llmChatHistory = [],
        functions = [create_call_graph_schema],
        } : Partial<CodebaseCallGraphAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, functions})

    }
}

export default CodebaseCallGraphAgent;
// src/chat/phases/twoStepCodebaseImplementationPhase.ts

    }

    public async *startNextFileImplementation(isFileAlreadyInExistingExtractions: boolean){
        let instructions = '';
        if (isFileAlreadyInExistingExtractions){
            instructions = 'continue';
        } else {
            for (let filePathIndex = 0; filePathIndex < this.filePaths.length; filePathIndex++){
                let filePath = this.filePaths[filePathIndex];
                let fileContent = this.fileContents[filePathIndex];
                instructions = instructions + '<Existing File: ' + filePath + '>\n\n' + fileContent + '\n\n</Existing File>\n\n';
            }
        }
        try {
			for await (const { message, messageIndex } of this.submitChatMessage(instructions, 'gpt-4-1106-preview', true)) {
				yield { message, messageIndex };
			}
		} catch (error: any) {
            throw error;
        }
    }
}
// src/config/tailwind-nextui-theme.ts

export const themes = {
    light: {
      colors: {
        background: "#f3f3f4", // or DEFAULT
        foreground: "#11181C", // or 50 to 900 DEFAULT
        primary: {
          //... 50 to 900
          foreground: "#FFFFFF",
          DEFAULT: "#006FEE",
        },
        // ... rest of the colors
      },
    },
    dark: {
      colors: {
        background: "#252526", // or DEFAULT
        foreground: "#ECEDEE", // or 50 to 900 DEFAULT
        content1: {
          //... 50 to 900
          foreground: "#FFFFFF",
          DEFAULT: "#333333",
        },
        default: {
          //... 50 to 900
          foreground: "#FFFFFF",
          DEFAULT: "#737373",
        },
        primary: {
          //... 50 to 900
          foreground: "#FFFFFF",
          DEFAULT: "#006FEE",
        },
      },
      // ... rest of the colors
    },
    mytheme: {
// src/chat/phases/basePhase.ts

		/*
		if (useOwnApiKey == true){
			if (model == 'gpt-4'){
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-4 Input Tokens Used', currentTotalTokenLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-4 Input Cost ($0.03/1000 tokens)', (currentTotalTokenLength / 1000) * 0.03);
			} else {
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-3.5 Input Tokens Used', currentTotalTokenLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'User API Key GPT-3.5 Input Cost ($0.002/1000 tokens)', (currentTotalTokenLength / 1000) * 0.002);
			}
		} else {
			if (model == 'gpt-4'){
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-4 Input Tokens Used', currentTotalTokenLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-4 Input Cost ($0.03/1000 tokens)', (currentTotalTokenLength / 1000) * 0.03);
			} else {
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-3.5 Input Tokens Used', currentTotalTokenLength);
				getMixPanel()?.people.increment(legacyWebviewViewProvider.getMachineId(), 'GPT-3.5 Input Cost ($0.002/1000 tokens)', (currentTotalTokenLength / 1000) * 0.002);
			}
		}*/
// src/types/agents.ts

import { EasyCodeClient, SelectedCodebaseContent } from "../apis/extensionToServerApi";
import { OpenAIClient } from "../apis/openaiClient";
import { AgentLLMChatMessage, EasyCodeChatMessage } from "./chatMessage";

export enum ChatAgentType{
    default,
    diff,
    askCodebase,
    askWeb,
    codebaseTwoStepPlanning,
    codebaseTwoStepImplementation,
    codebaseCallGraph,
    codebaseExplain,
    codebaseDiffImplementation,
    codebaseImplementation,
    codeFeedback,
    readFileContent
  }

export interface Agent {
    type: ChatAgentType;
    systemMessage: string;
    firstMessagePromptPre: string;
    firstMessagePromptPost: string;
    followUpMessagePromptPre: string;
    followUpMessagePromptPost: string;
    shouldRetrieveInFollowUps: boolean;
    llmChatHistory: AgentLLMChatMessage[];
    createChatMessages: (messages: EasyCodeChatMessage[], model?: string) => Promise<void>;
    submitChatMessage: (model:string) => AsyncGenerator<any, any, any>
}
// src/sentry/node-extension-telemetry.ts

        integrations: [
            // default integrations
            new SentryNode.Integrations.InboundFilters(),
            new SentryNode.Integrations.FunctionToString(),
            new SentryNode.Integrations.Http(),
            new SentryNode.Integrations.Undici(),
            new SentryNode.Integrations.ContextLines(),
            new SentryNode.Integrations.Context(),
            new SentryNode.Integrations.LinkedErrors(),

            // other integrations
            new ExtraErrorData(),
        ],
    });
// src/chat/phases/basePhase.ts

		*/

		let userMessage: EasyCodeChatMessage = {
			role: 'user',
			content,
		};

		if (!doNotEchoOrStore){
			yield { message: userMessage, messageIndex: this.messageHistory.length};
			//console.log(userMessage.content?.substring(userMessage.content.length - 15));

			userMessage['easyCodeMetadata'] = {model, isAskCodebase: false, isAskWeb: false, origUserQuery: content};
			//userMessage['easyCodeMetadata'] = {model, isAskCodebase: isAskCodebase || false, isAskWeb: isAskWeb || false, selectedCodebaseContent: selectedCodebaseContent ? selectedCodebaseContent: undefined, origUserQuery: content, agent: agent ? agent : undefined};


			//console.log(tabListeners[tabId]);

			this.messageHistory.push(userMessage);
		}



		//console.log(userMessage.content?.substring(userMessage.content.length - 15));

		/*
// src/chat/agents/baseAgent.ts

    constructor(
        {
            type = ChatAgentType.default,
            systemMessage = "You are an AI coding assistant.",
            firstMessagePromptPre = "",
            firstMessagePromptPost = "",
            followUpMessagePromptPre = "",
            followUpMessagePromptPost = "",
            shouldRetrieveInFollowUps = false,
            llmChatHistory = [],
            functions = undefined
        }: Partial<BaseAgent> = {}
    ) {
        this.type = type;
        this.systemMessage = systemMessage;
        this.firstMessagePromptPre = firstMessagePromptPre;
        this.firstMessagePromptPost = firstMessagePromptPost;
        this.followUpMessagePromptPre = followUpMessagePromptPre;
        this.followUpMessagePromptPost = followUpMessagePromptPost;
        this.shouldRetrieveInFollowUps = shouldRetrieveInFollowUps;
        this.llmChatHistory = llmChatHistory;
        this.functions = functions;
    }

    public async populateSystemMessageIfNewChat(){
// src/chat/chats/diffCodebaseImplementationChat.ts

        try {
            let aiResponse = "";
            for await (let { message, messageIndex } of codebaseDiffImplementationPhase.submitChatMessage(content, model, doNotEchoOrStore)){
// src/chat/chats/diffCodebaseImplementationChat.ts

                    if (diffsList && diffsList.length > 0){


                        if (editor) {

                            selectionList = [];
                            newCodeList = [];
                            for (let diffIndex = 0; diffIndex < diffsList.length; diffIndex++){
// src/chat/agents/defaultAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage } from "../../types/chatMessage"
import BaseAgent from "./baseAgent";

export class DefaultAgent extends BaseAgent {

}

export default DefaultAgent;
// src/chat/phases/diffPhase.ts

								*/
								let originalCode = diffsList[diffIndex]["old_code"];
								let updatedCode = diffsList[diffIndex]["new_code"];
								if (!originalCode || !updatedCode){
									continue;
								}
								console.log("ORIGINAL CODE");
								console.log(originalCode);
								console.log("UPDATED CODE");
								console.log(updatedCode);

								let selection = await selectFirstMatchInDocument(originalCode, editor);
								if (selection){
// src/chat/agents/baseAgent.ts

import { ChatCompletionFunctions } from "openai";
import { EasyCodeClient, SelectedCodebaseContent } from "../../apis/extensionToServerApi";
import { OpenAIClient } from "../../apis/openaiClient";
import { Globals } from "../../config/globals";
import { truncateFromTop } from "../../helpers/chatHistory";
import { createPrompt } from "../../helpers/prompt";
import { calcMaxAvailableTokens, countMessageHistoryTokens } from "../../helpers/tokenCounters";
import { extractPromptFilesAndMethods, removeMessageHistoryFromIndex } from "../../helpers/utils";
import { appendFileSkeletonContent } from "../../modules/fileSkeleton";
import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage, EasyCodeChatMessage } from "../../types/chatMessage"

export class BaseAgent implements Agent {
// src/chat/agents/function_schemas/function_schemas.ts

    },
    description: "Make edits to the code file.",
}
// src/helpers/prompt.ts

	/*
	This used to be needed with the old code running UI, but is no longer necessary and offers
	more flexibility in switching between languages without locking gpt into the same language
	*/

	/*
	if (codeEvalLang in codeEvalExampleScript) {
		messageHistory.push(
			{
				role: 'assistant',
				// https://github.com/openai/openai-node/issues/195
				// @ts-ignore
				content: null,
				function_call: {
					name: codeEvalLang,
					arguments: JSON.stringify({ script: codeEvalExampleScript[codeEvalLang] }),
				},
			}
		);
	}*/
};
// src/apis/openaiClient.ts

                        } else {
                            /*
                            this._messageHistory[this._tabIndex].push({
                                role: 'assistant',
                                // https://github.com/openai/openai-node/issues/195
                                // @ts-ignore
                                content: null,
                                // re-stringify arguments to minify JSON
                                function_call: { ...functionCall, arguments: JSON.stringify(parsedArguments) },
                                easyCodeMetadata: { ...easyCodeMetadata, isMessageComplete },
                            });*/
                        }
// src/helpers/utils.ts

		} else if (firstUserMessage.content.includes("Based on the code and files above, ")) {
			firstUserMessage.content = firstUserMessage.content.split("Based on the code and files above, ")[firstUserMessage.content.split("Based on the code and files above, ").length-1];
		} else if (firstUserMessage.content.includes("Based on the text above, ")) {
			firstUserMessage.content = firstUserMessage.content.split("Based on the text above, ")[firstUserMessage.content.split("Based on the text above, ").length-1];
		} else if (firstUserMessage.content.includes("\n</relevant_selected_code>\n")) {
			firstUserMessage.content = firstUserMessage.content.split("\n</relevant_selected_code>\n")[firstUserMessage.content.split("\n</relevant_selected_code>\n").length-1];
		}
// src/chat/agents/codebaseDiffPerFileImplementationAgent.ts

    }
}

export default CodebaseDiffPerFileImplementationAgent;
// src/chat/phases/twoStepCodebaseImplementationPhase.ts

        try {
			for await (const { message, messageIndex } of this.submitChatMessage(filePathsAndContents, 'gpt-4-1106-preview', true)) {
				yield { message, messageIndex };
			}
		} catch (error: any) {
            throw error;
        }
    }
// src/webview/components/AppNav.tsx

      <NavbarMenu style={{ backgroundColor: "#252526" }}>
        <NavbarMenuItem>
          <CommandLink
            command="workbench.action.openWalkthrough"
            args="EasyCodeAI.chatgpt-gpt4-gpt3-vscode#welcome"
          >
            Tutorial
          </CommandLink>
        </NavbarMenuItem>
        <NavbarMenuItem>
          <ExternalLink url={new URL("https://tally.so/r/n9X2YY")}>
            Support
          </ExternalLink>
        </NavbarMenuItem>
        <NavbarMenuItem>
          <CommandLink
            command="workbench.action.openSettings"
            args="@ext:EasyCodeAI.chatgpt-gpt4-gpt3-vscode"
          >
            Settings
          </CommandLink>
        </NavbarMenuItem>
        <NavbarMenuItem>
          {userProfile?.isPlaceholderAccount !== false ? (
            <span
              className="w-full hover:text-blue-500 text-white text-lg cursor-pointer"
              onClick={() => handleLogoutAndSignUp(navigate)}
            >
              Sign Up
            </span>
          ) : (
            <span
// src/chat/agents/codebaseDiffPerFileImplementationAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { DefaultAskCodebaseAgent } from "./defaultAskCodebaseAgent";
import { search_and_replace_schema_next_file } from "./function_schemas/function_schemas";

export class CodebaseDiffPerFileImplementationAgent extends DefaultAskCodebaseAgent {
// src/config/tailwind-nextui-theme.ts

    mytheme: {
      // custom theme
      extend: "dark",
      colors: {
        primary: {
          DEFAULT: "#BEF264",
          foreground: "#000000",
        },
        focus: "#BEF264",
      },
    },
  }
// src/modules/generateCommitMessage.ts

            let generateCommitMessageUserMessage: EasyCodeChatMessage = {
                role: 'user',
                content: allFileDiffs + '\n\nBased on the above file diffs, write a commit message.',
            };

            let messages = [generateCommitMessageSystemMessage, generateCommitMessageUserMessage];
            let model = Globals.getSettings().model;
			try {
				for await (const data of easyCodeClient.submitChatMessage({ model: model ? model : "gpt-4", messages: messages})) {
					//console.log(data);
					streamingCommitMessageResponse += data;
                    // Set the commit message
                    if (repo.inputBox) {
                        repo.inputBox.value = streamingCommitMessageResponse;
                    }
				}
			} catch (error:any) {
				if (error != 'STOPSIGNAL' && error != 'User Stopped Streaming'){
					console.log(error);
				}
				if (error == 'STOPSIGNAL'){
					//messageComplete = true;
				}
			}
    }
// src/webview/redux/webviewToExtensionApi.ts

  endpoints: (builder) => ({
    login: builder.mutation<
      { user: EasyCodeUser },
      { email?: string | null; password?: string | null }
    >({
      query(data) {
        return {
          type: "login",
          data,
        };
      },
      invalidatesTags: ["User", "MessageHistoryList"],
    }),
    signup: builder.mutation<
      { user: EasyCodeUser },
      { email?: string | null; password?: string | null; role?: string | null }
    >({
      query(data) {
        return {
          type: "signup",
          data,
        };
      },
      invalidatesTags: ["User"],
    }),
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    loginWithPlaceholder: builder.mutation<{ user: EasyCodeUser }, void>({
      query() {
        return {
          type: "login-with-placeholder",
        };
      },
      invalidatesTags: ["User"],
    }),
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    forgotPassword: builder.mutation<
// src/webview/pages/components/AskCodebasePanel.tsx

          <span className="">Exclude Directories</span>
        </div>

      </div>
    );
  };
// src/chat/agents/diffAgent.ts

export class DiffAgent extends BaseAgent {

    constructor(
        {
            type = ChatAgentType.diff,
            //systemMessage = "Context Diff Format: \n\n*** ****\noriginal_lines_of_code\n--- ----\nupdated_lines_of_code.\n\nYou are an AI coding assistant that will answer in a context diff format. You will always format your answer as a context diff code block (```). A context diff contains multiple hunks, where each hunk will contain original_lines_of_code from the source code that need to be replaced with updated_lines_of_code. You must follow these rules when when creating each hunk:\n\n-original_lines_of_code must not be empty. Fill it with the full lines of code from the source code that needs to be replaced.\n-Be very careful when writing the diff. Your changes should not accidentally break or remove existing lines. You can reprint existing lines at the bottom or top of the updated lines.\n-original_lines_of_code is continguous and must be copied exactly from the source code, without any altering or adjustments.\n-The hunk cannot contain code abbreviations or pseudocode like (//), (...), (// ...rest of), (// ...existing), (// ...other), you must return actual lines of code.\n\nAlways format your code blocks as a context diff with multiple hunks of this format:\n\n*** ****\noriginal_lines_of_code\n--- ----\nupdated_lines_of_code.",
// src/helpers/utils.ts

	if (firstUserMessage?.content?.length){
		if (firstUserMessage.content.includes("Based on the code snippets and file summaries above, ")){
			firstUserMessage.content = firstUserMessage.content.split("Based on the code snippets and file summaries above, ")[firstUserMessage.content.split("Based on the code snippets and file summaries above, ").length-1];
		} else if (firstUserMessage.content.includes("Based on the code and files above, ")) {
// src/chat/phases/twoStepCodebaseImplementationPhase.ts

export class TwoStepCodebaseImplementationPhase extends BasePhase {
    public implementationPlan: string;
    public pastMessagesWithoutFileContent: EasyCodeChatMessage[];
    public filePaths: string[];
    public fileContents: string[];
    public selectedCodebaseContent: SelectedCodebaseContent;
    constructor(
// src/sentry/node-extension-telemetry.ts

    });
};
// src/chat/agents/baseAgent.ts

		} else {
			//This for loop is for an experimental FLARE implementation, ignore this for production
			//for (var i = 0; i < 20; i++){
				try {
					for await (const data of Globals.getEasyCodeClient().submitChatMessage({ model: model ? model : "gpt-4", messages: this.llmChatHistory, functions: this.functions ? this.functions : undefined})) {
						//console.log(data);
						streamingEasyCodeChatMessage.content += data;
                        //console.log(streamingEasyCodeChatMessage.content);
						yield streamingEasyCodeChatMessage;
					}
				} catch (error:any) {
                    if (error == 'STOPSIGNAL'){
                        streamingEasyCodeChatMessage['easyCodeMetadata'].finishedStreaming = true;
                        this.llmChatHistory.push(streamingEasyCodeChatMessage);
                    }
                    throw error;
				}
			//}
		}
// src/modules/codeLensProvider.ts

        const findLenses = (symbols: DocumentSymbol[]) => {
            symbols.forEach(({ kind, range, children }) => {
                if ([vscode.SymbolKind.Constructor, vscode.SymbolKind.Method, vscode.SymbolKind.Function].includes(kind)) {
                    const symbolCodeLenses = [
                        ['Ask EasyCode', 'easycode.ask'],
                        ['Explain', 'easycode.explain'],
                        ['Refactor', 'easycode.refactorCode'],
                    ]
                        .map(([title, command]) => new vscode.CodeLens(
                            range,
                            {
                                title,
                                command,
                                arguments: [uri, range],
                            },
                        ));

                    lenses.push(...symbolCodeLenses);
                }

                children?.length && findLenses(children);
            });
        };
        findLenses(symbols);

        return lenses;
    },
// src/modules/generateCommitMessage.ts

    }
}
// src/modules/generateCommitMessage.ts

import * as vscode from 'vscode';
import { EasyCodeClient } from '../apis/extensionToServerApi';
import { EasyCodeChatMessage } from '../types/chatMessage';
import { Globals } from '../config/globals';

export async function generateCommitMessage(easyCodeClient: EasyCodeClient){
// src/helpers/utils.ts

			} else if (firstUserMessage.content.includes("Based on the code and files above, ")) {
				tabTitle = firstUserMessage.content.split("Based on the code and files above, ")[firstUserMessage.content.split("Based on the code and files above, ").length-1].substring(0, maxLength);
			} else if (firstUserMessage.content.includes("Based on the text above, ")) {
				tabTitle = firstUserMessage.content.split("Based on the text above, ")[firstUserMessage.content.split("Based on the text above, ").length-1].substring(0, maxLength);
			} else if (firstUserMessage.content.includes("\n")){
				tabTitle = firstUserMessage.content.split("\n")[firstUserMessage.content.split("\n").length-1].substring(0, maxLength);
			} else {
				tabTitle = firstUserMessage.content.substring(0, maxLength);
			}
// src/chat/phases/codebaseExplainPhase.ts

import CodebaseExplainAgent from "../agents/codebaseExplainAgent"
import CodebaseDiffPerFileImplementationAgent from "../agents/codebaseDiffPerFileImplementationAgent";
import CodebaseTwoStepPlanningAgent from "../agents/codebaseTwoStepPlanningAgent";
import DefaultAskCodebaseAgent from "../agents/defaultAskCodebaseAgent";
import { Agent } from "../../types/agents";
import BasePhase from "./basePhase";

export class CodebaseExplainPhase extends BasePhase {
    constructor(
        {
			agents = [new CodebaseExplainAgent()],
		}: Partial<BasePhase> = {}
    ) {
        super({agents: agents});
    }
}

export default CodebaseExplainPhase;
// src/helpers/utils.ts

		if (firstUserMessage?.content?.length){
			if (firstUserMessage.content.includes("Based on the code snippets and file summaries above, ")){
				tabTitle = firstUserMessage.content.split("Based on the code snippets and file summaries above, ")[firstUserMessage.content.split("Based on the code snippets and file summaries above, ").length-1].substring(0, maxLength);
			} else if (firstUserMessage.content.includes("Based on the code and files above, ")) {
// src/webview/components/EditorContextMenuListener.tsx

      switch (message.type) {
        case 'contextMenuOptionSelected':
          console.log(message.data);
          if (message.data.option == 'ask'){
          // Dispatch an action to extensionApi
          //console.log(message);
          //console.log("dispatching setInputText Action");
            dispatch(webviewToExtensionApi.endpoints.addTab.initiate()).then(result => {
              if ('data' in result){
                let newTabId = result?.data.newTabId;
                dispatch(inputText.actions.setInputText({text: message.data.selectedText + '\n\n' + message.data.input, tabId: newTabId}));
              }
            })
          } else if (message.data.option == 'index-codebase'){
            dispatch(webviewToExtensionApi.endpoints.indexCodebase.initiate())
          } else if (message.data.option == 'refresh-file-tree'){
            dispatch(webviewToExtensionApi.util.invalidateTags(['FileTree']));
          }
          break;
        case 'fixIssue':
// src/chat/chats/defaultChat.ts

import BaseChat from "./baseChat";

export class DefaultChat extends BaseChat {
    constructor(
        params: Partial<DefaultChat> = {}
    ) {
        super(params);
    }
}

export default DefaultChat;
// src/webview/redux/uiActions.ts

// src/webview/redux/uiActions.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface InputTextState {
    text: string;
    tabId: string | null;
    isLoading: boolean;
    error: any;
}

interface InputTextPayload {
    text: string;
    tabId: string;
}

const initialInputTextState: InputTextState = {
    text: '',
    tabId: null,
    isLoading: false,
    error: null,
};

const inputTextSlice = createSlice({
    name: 'inputText',
    initialState: initialInputTextState,
    reducers: {
      setInputText: (state, action: PayloadAction<InputTextPayload>) => {
        state.text = action.payload.text;
        state.tabId = action.payload.tabId;
      },
      // other reducers...
    },
});

const followUpInputTextSlice = createSlice({
// src/chat/agents/function_schemas/function_schemas.ts

        properties: {
            current_file: {
                type: "string",
                description: "Identify the current file that needs to be changed.",
            },
            analysis_and_identification: {
                type: "string",
                description: "Identify and list the minimal changes that need to be made to the file, by listing all locations that should receive these changes and the changes to be made. Be sure to consider all imports that are required to complete the task.",
            },
            replaces_to_make: {
// src/chat/phases/diffPhase.ts

            }
        } catch (error: any) {
            if (error == 'STOPSIGNAL'){

                if (selectionList.length > 0 && newCodeList.length > 0 && editor){

                    if (debouncedCreateOrUpdateDiffView) {
                        debouncedCreateOrUpdateDiffView.flush(); // Assuming you have a flush method on your debounced function
                    }
                    showApplyChangesNotification(editor.document, selectionList, newCodeList);
                }

            }
            throw error;
        }
// src/chat/chats/askCodebaseChat.ts

import { Chat, ChatType } from "../../types/chat";
import { ChatPhase } from "../../types/chatPhase";
import BaseChat from "./baseChat";
import AskCodebasePhase from "../phases/askCodebasePhase";
import BasePhase from "../phases/basePhase";

export class AskCodebaseChat extends BaseChat {

    constructor(
        {
            type = ChatType.askCodebase,
            phases = [new AskCodebasePhase()],
            currentPhaseIndex = 0,
            title = ''
        }: Partial<AskCodebaseChat> = {}
    ) {
        super({ type, phases, currentPhaseIndex, title });
    }
}

export default AskCodebaseChat;
// src/modules/codeLensProvider.ts

    },
});
// src/chat/phases/diffPhase.ts

                if (message.role == 'assistant'){
					if (message.content){
						aiResponse = message.content;
					}
					let function_call_response = partialParseJson(aiResponse);

					let file_name = function_call_response.file_name;
					let diffsList = function_call_response.replaces_to_make;
					if (file_name && !editor && doesMessageContainFilePath(file_name)){

						let { fileUris } = await extractFileContentsFromMessageContainingFilePaths(file_name, undefined, false, false)
						//take the first filePath
						if (fileUris && fileUris.length > 0){
							let fileUri = fileUris[0];

							if (!fileUri){
								throw("File not found for current message");
							}

							let document = await vscode.workspace.openTextDocument(fileUri);

							editor = await vscode.window.showTextDocument(document);

						}
					}

					/*
// src/webview/pages/components/UpgradeModal.tsx

              {/*
              <>
                <p>
                  GPT-4 turbo credit packs are $5 for 450,000 input tokens
                </p>
                <Button radius='sm' color='primary' variant='shadow' onClick={(e) => dispatch(webviewToExtensionApi.endpoints.openUpgradeExternalLink.initiate({plan: "gpt-4-credits", user: userProfile}))}>
                  <IoRocketOutline className="w-6 h-6" /> Get GPT-4 Credits
                </Button>
              </>
              {!(userProfile.subscribed) &&
                <>
                  <p>
                    The GPT-3.5 Pro Plan ($7 / month) provides unlimited GPT-3.5 & Claude-Instant-1, including web browsing, & in-line autocomplete
                  </p>
                  <Button radius='sm' color='primary' variant='shadow' onClick={(e) => dispatch(webviewToExtensionApi.endpoints.openUpgradeExternalLink.initiate({plan: "gpt-3.5-pro", user: userProfile}))}>
                  <IoRocketOutline className="w-6 h-6" /> Get GPT-3.5 Pro
                  </Button>
                </>
              }
              {!(userProfile.subscribedCodebase) &&
                <>
                  <p>
                    The Codebase Pro Plan ($20 / month) includes unlimited ask codebase with a higher limit of 1000 files. The gpt-3.5-pro plan is included
                  </p>
                  <Button radius='sm' color='primary' variant='shadow' onClick={(e) => dispatch(webviewToExtensionApi.endpoints.openUpgradeExternalLink.initiate({plan: "codebase-pro", user: userProfile}))}>
                    <IoRocketOutline className="w-6 h-6" />Get Codebase Pro
                  </Button>
                </>
              }
              {(userProfile.subscribed || userProfile.subscribedCodebase) &&
              <>
                <p>
                  Enter the billing portal to manage or change your subscription
                </p>
                <Button radius='sm' color='primary' variant='shadow' onClick={(e) => dispatch(webviewToExtensionApi.endpoints.openManageSubscriptionExternalLink.initiate({user: userProfile}))}>
                  <IoCardOutline className="w-6 h-6" />Manage Subscription
                </Button>
              </>
              }
              */}
// src/sentry/node-extension-telemetry.ts

export const initializeExtensionSentry = () => {
    SentryNode.init({
        enabled: !!process.env.SENTRY_ENABLED,
        release: `${process.env.npm_package_name}@${process.env.npm_package_version}`,
        environment: process.env.NODE_ENV,
        dsn: "https://6eca0b151027458aae43c25d5ea2c29c@o4505094109331456.ingest.sentry.io/4505094113787904",
        // Set tracesSampleRate to 1.0 to capture 100%
        // of transactions for performance monitoring.
        // We recommend adjusting this value in production
        tracesSampleRate: 0.01,
        tracePropagationTargets: [
            easycode_url,
            // inline completion endpoint
            '209.20.159.29',
        ],

        sendDefaultPii: true,

        initialScope: scope => (
            scope
                .setUser(createSentryUser())
                .setTags(createSentryTags())
                .setContext('Environment Variables', runtimeProcess.env)
        ),

        // enable integrations manually to avoid problematic integrations
        defaultIntegrations: false,
        integrations: [
// src/types/chatMessage.ts

  export interface UserAgentChatMessage extends ChatCompletionRequestMessage {
    easyCodeMetadata?: {
      model?: string,
      modelType?: string,
      feedback?: 'positive' | 'negative',
      isMessageComplete?: boolean,
      useOwnApiKey?: boolean,
      isAskCodebase?: boolean,
      isAskWeb?: boolean,
      useActiveViewContext?: boolean,
      promptRevised?: boolean,
      selectedCodebaseContent?: SelectedCodebaseContent,
      origUserQuery?: string;
      agentType?: ChatAgentType;
      finishedStreaming?: boolean;
    };
  }

  export interface AgentLLMChatMessage extends ChatCompletionRequestMessage {
// src/chat/agents/askWebAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage } from "../../types/chatMessage"
import BaseAgent from "./baseAgent";

export class AskWebAgent extends BaseAgent {

    constructor(
        public type: ChatAgentType = ChatAgentType.askWeb,
        public systemMessage: string = "You are an AI coding assistant.",
        public firstMessagePromptPre: string = "Based on the text above, ",
        public firstMessagePromptPost: string = "",
        public followUpMessagePromptPre: string = "",
        public followUpMessagePromptPost: string = "",
        public shouldRetrieveInFollowUps: boolean = true,
        public llmChatHistory: AgentLLMChatMessage[] = []
    ) {
        super();
    }
}

export default AskWebAgent;
// src/webview/pages/components/AccountModal.tsx

              <div className="flex flex-row"><IoBatteryHalf className="h-6 w-6 mr-2" /><span className='text-md'>Rate Limits:</span></div>
            </p>
            <li className="ml-3">
              {'GPT-4: '}
              {((userProfile?.gpt4TokensTotal && userProfile?.gpt4TokensUsed && (userProfile.gpt4TokensTotal > userProfile.gpt4TokensUsed)) ? (userProfile?.gpt4TokensTotal - userProfile?.gpt4TokensUsed + ' tokens remaining') : '5 requests every 4 hours')}
            </li>
            <li className="ml-3">
              {'GPT-3 / Claude: ' + (userProfile?.subscribed ? "Unlimited" : '10 requests every 20 minutes')}
            </li>
            <li className="ml-3">
              {'Ask Codebase: ' + (userProfile?.subscribedCodebase ? "Unlimited" : '20 requests every month')}
            </li>
            <Button className="mt-4" radius='sm' color='primary' variant='shadow' onClick={(e:any) => setIsUpgradeModalOpen(true)}>
              <IoRocketOutline className="w-6 h-6" />Upgrade
// src/helpers/tokenCounters.ts

export function calcMaxAvailableTokens(model: string){

    let modelMaxAvailableToken = 0;
    if (model == 'gpt-4') {
        modelMaxAvailableToken = 8192;
    } else if (model == 'gpt-4-32k'){
        modelMaxAvailableToken = 32768;
    } else if (model == 'gpt-4-1106-preview'){
        modelMaxAvailableToken = 65536;
    } else if (model == 'gpt-3.5-turbo-16k'){
        modelMaxAvailableToken = 16384;
    } else if (model == 'gpt-3.5-turbo') {
        modelMaxAvailableToken = 4096;
    } else if (model == 'claude-instant-1'){
        modelMaxAvailableToken = 32768;
    } else if (model == 'claude-2'){
        modelMaxAvailableToken = 90000;
    } else if (model == 'easycode-0.1'){
        modelMaxAvailableToken = 3496;
    }
    let maxAvailableToken = (modelMaxAvailableToken - (Globals.getSettings().maxTokens || 1024) - 100);
    return maxAvailableToken;
}
/**
// src/helpers/utils.ts

export async function extractFileContentsFromMessageContainingFilePaths(message:string, selectedCodebaseContent: SelectedCodebaseContent | undefined, useLast: boolean, useLLM: boolean = true){


	let instruction = '';
	let filePaths = [];
	if (useLLM){
		if (useLast){
			instruction = "Give me the file path(s) that will be worked on next. The file path(s) should be at the end of the message."
			let filePathsString = await Globals.getEasyCodeClient().extractFilePathsFromPlan({message: message, instruction: instruction})
			filePaths = extractFilePaths(filePathsString);
		} else {
			instruction = "Give me the file path(s) listed in the steps of this implementation."
			let filePathsString = await Globals.getEasyCodeClient().extractFilePathsFromPlan({message: message, instruction: instruction})
			filePaths = extractFilePaths(filePathsString);
		}
	} else {
		filePaths = extractFilePaths(message);
	}

	if (filePaths.length == 0){
		return {};
	}

	for (let filePathIndex = 0; filePathIndex < filePaths.length; filePathIndex++){
		filePaths[filePathIndex] = filePaths[filePathIndex].replace(/^\W+|\W+$/g, '');
	}

	let maxFilesReadAtOnce = 1;
	filePaths = filePaths.slice(0, maxFilesReadAtOnce);

	let fileContents = [];
// src/modules/generateCommitMessage.ts

            let generateCommitMessageSystemMessage: EasyCodeChatMessage = {
                role: 'system',
                content:
`Git Commit Message Format:

Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Each line should wrap to about 72
characters or so.  The first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical; tools like rebase can get confused if you run the
two together.

Write your commit message in the imperative form: "Fix bug" and not "Fixed bug"
or "Fixes bug."  This convention matches up with commit messages generated
by commands like git merge and git revert.

You are a git commit message generator that will write a commit message following the format above.`,
            };

            let generateCommitMessageUserMessage: EasyCodeChatMessage = {
// src/chat/agents/function_schemas/function_schemas.ts

            replaces_to_make: {
                type: "array",
                description: "Array of sections to modify",
                items: {
                    type: "object",
                    properties: {
                        section_id: {
                            type: "string",
                            description: "The section ID the original code belongs to.",
                        },
                        old_code: {
                            type: "string",
                            description: "The old lines of code that belongs to section with ID section_id. Be sure to add lines before and after to disambiguate the change.",
                        },
                        new_code: {
                            type: "string",
                            description: "The new code to replace the old code.",
                        },
                    },
                    required: ["section_id", "old_code", "new_code"],
                },
            },
            next_file: {
// src/chat/agents/codeFeedbackAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage } from "../../types/chatMessage"
import BaseAgent from "./baseAgent";

export class CodeFeedbackAgent extends BaseAgent {

    constructor(
        public type: ChatAgentType = ChatAgentType.codeFeedback,
        public systemMessage: string = "You are a code linter that will reply with an error message for the code provided. You will make up an error for your first reply. Your second reply must be 'SUCCESS'",
        public firstMessagePromptPre: string = "",
        public firstMessagePromptPost: string = "",
        public followUpMessagePromptPre: string = "",
        public followUpMessagePromptPost: string = "",
        public shouldRetrieveInFollowUps: boolean = true,
        public llmChatHistory: AgentLLMChatMessage[] = [],
    ) {
        super();
    }
}

export default CodeFeedbackAgent;
// src/webview/redux/webviewToExtensionApi.ts

    forgotPassword: builder.mutation<
      { success: boolean },
      { email?: string | null }
    >({
      query(data) {
        return {
          type: "forgot-password",
          data,
        };
      },
      //TODO: figure this out later: invalidatesTags: ['User'],
    }),
    logout: builder.mutation<void, void>({
      query() {
        return {
          type: "logout",
        };
      },
      invalidatesTags: ["User"],
    }),
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    isLoggedIn: builder.query<{ isLoggedIn: boolean }, void>({
      query() {
        return {
          type: "is-user-logged-in",
        };
      },
      providesTags: ["User"],
    }),
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    getUserProfile: builder.query<{ user: EasyCodeUser }, void>({
// src/chat/chats/codebaseImplementationChat.ts

import { ChatAction, ChatType } from "../../types/chat";
import BaseChat from "./baseChat";
import CodebaseImplementationPhase from "../phases/codebaseImplementationPhase";

export class CodebaseImplementationChat extends BaseChat {
// src/types/chatMessage.ts

  export interface AgentLLMChatMessage extends ChatCompletionRequestMessage {
    easyCodeMetadata?: {
      model?: string,
      modelType?: string,
      feedback?: 'positive' | 'negative',
      isMessageComplete?: boolean,
      useOwnApiKey?: boolean,
      isAskCodebase?: boolean,
      isAskWeb?: boolean,
      useActiveViewContext?: boolean,
      promptRevised?: boolean,
      selectedCodebaseContent?: SelectedCodebaseContent,
      origUserQuery?: string;
      agentType?: ChatAgentType;
      finishedStreaming?: boolean;
    };
  }
// src/types/chat.ts

import { ChatPhase } from "./chatPhase";

export enum ChatType {
    uninitialized,
    default,
    askCodebase,
    codebaseExplain,
    codebaseTwoStepPlanningAndImplementation,
    codebaseSearch,
    codebaseImplementation,
    codebaseDiffImplementation
}

export enum ChatAction {
    startCodebaseImplementationCoding,
    startNextFileImplementation,
    viewCurrentCodebaseImplementationPlan,
    generateCodeDiff
}

export enum ChatCommand {
    DiffModify = "DiffModify",
    DiffImplement = "DiffImplement",
    Implement = "Implement",
    Explain = "Explain",
    CallGraph = "CallGraph",
    PlanAndImplement = "PlanAndImplement",
    Search = "Search"
}

export interface Chat {
    type: ChatType,
    phases: ChatPhase[],
    currentPhaseIndex: number,
    title: string,
    actions: ChatAction[],
    evokeAction: (action: ChatAction) => AsyncGenerator<any, any, any>,
    submitChatMessage: (content:string, model:string) => AsyncGenerator<any, any, any>

}
// src/modules/fileSkeleton.ts

                }
                return result;
            }));

            for (const result of results) {
                fileSkeletonContent += result;
            }
        }
        if (fileSkeletonContent) {
            fileSkeletonContent = '\n\n<relevant_selected_code>\n\n' + fileSkeletonContent + '\n</relevant_selected_code>\n';
        }
    }
// src/webview/redux/webviewToExtensionApi.ts

    getUserProfile: builder.query<{ user: EasyCodeUser }, void>({
      query() {
        return {
          type: "user-profile",
        };
      },
      // profile fetch is slow, use a long cache ttl
      keepUnusedDataFor: Infinity,
      providesTags: ["User"],
    }),
    goToCode: builder.query<
      void,
      { text: string; isFileName: boolean; tabId: string; messageIndex: number }
    >({
      query(data) {
        return {
          type: "go-to-code",
          data,
        };
      },
    }),
    openUpgradeExternalLink: builder.mutation<
      void,
      { plan: string; user: EasyCodeUser }
    >({
      query(data) {
        return {
          type: "open-upgrade-external-link",
          data,
        };
      },
    }),
    openManageSubscriptionExternalLink: builder.mutation<
      void,
      { user: EasyCodeUser }
    >({
      query(data) {
        return {
          type: "open-manage-subscription-external-link",
          data,
        };
      },
    }),
    setModel: builder.mutation<void, { model: string }>({
// src/webview/pages/components/AskCodebasePanel.tsx

    const handleDeleteDirectory = (event:any, selectedFolderPath: string) => {
      store.dispatch(webviewToExtensionApi.endpoints.deleteDirectory.initiate({selectedFolderPath}));
    }
    const handleAddDirectory = (event: any) => {
      store.dispatch(webviewToExtensionApi.endpoints.indexLocalDirectory.initiate());
    }

    const handleExcludeDirectories = (event: any) => {
      store.dispatch(webviewToExtensionApi.endpoints.openPrimaryGitIgnoreFile.initiate());
    }

    const handleCheckboxChange = async (node: FileTreeNode, selectedFolderPath: string, isProjectRoot: boolean, selected: boolean) => {
// src/webview/pages/components/AskCodebasePanel.tsx

    const handleCheckboxChange = async (node: FileTreeNode, selectedFolderPath: string, isProjectRoot: boolean, selected: boolean) => {

      console.log("handleCheckboxChange");
      if (data){
        store.dispatch(webviewToExtensionApi.endpoints.selectOrUnselectNode.initiate({fileNode: node, selected: selected, selectedFolderPath: selectedFolderPath, isProjectRoot: isProjectRoot}));
      }
      setAllDirectoryData(prevDirectoryDatas => {
        if (!prevDirectoryDatas) return prevDirectoryDatas;
        return prevDirectoryDatas.map((prevDirectoryData) => {
          if (prevDirectoryData.selectedFolderPath == selectedFolderPath){
            prevDirectoryData.fileTree[0] = updateSelectedNodeAndChildren(prevDirectoryData.fileTree[0], node.path, selected);
          }
          return prevDirectoryData;
        });
      });
    };
    //let fileTree = data?.fileTree[0];
    return (
      <div className="">
        {allDirectoryData?.map(directoryData =>
        <div className="flex flex-row">
// src/chat/agents/baseAgent.ts

		}

    }
}

export default BaseAgent;
// src/chat/phases/codebaseImplementationPhase.ts


import CodebasePerFileImplementationAgent from "../agents/codebasePerFileImplementationAgent";
import BasePhase from "./basePhase";

export class CodebaseImplementationPhase extends BasePhase {
    constructor(
        {
			agents = [new CodebasePerFileImplementationAgent()],
		}: Partial<BasePhase> = {}
    ) {
        super({agents: agents});
    }
}

export default CodebaseImplementationPhase;
// src/chat/phases/diffPhase.ts

							for (let diffIndex = 0; diffIndex < diffsList.length; diffIndex++){

								/*
								if (!(diffsList[diffIndex].includes('---')) && !(diffsList[diffIndex].includes('----')) || !(diffsList[diffIndex].includes('****'))){
									continue;
								}

								let originalCode = diffsList[diffIndex].split('---')[0].split('****')[1];
								if (originalCode.startsWith('\n')){
									originalCode = originalCode.slice(1);
								}
								if (originalCode.endsWith('\n')){
									originalCode = originalCode.slice(0, -1);
								}
								let updatedCode = diffsList[diffIndex].split('----')[1];
								if (updatedCode.includes('***')){
									updatedCode = updatedCode.split('***')[0];
								}
								if (updatedCode.startsWith('\n')){
									updatedCode = updatedCode.slice(1);
								}
								if (updatedCode.endsWith('\n')){
									updatedCode = updatedCode.slice(0, -1);
								}
								originalCode = removeExclamationFromStartIfExists(originalCode);
								if ((originalCode.trim().length == 0)){
									originalCode = extractFirstBlockAbovePlus(updatedCode);
									updatedCode = originalCode + extractFirstPlusBlock(updatedCode);
									if (originalCode.trim().length == 0){
										continue;
									}
								}

								updatedCode = removePlusAndExclamationFromStartIfExists(updatedCode);
								*/
// src/sentry/react-webview-telemetry.ts

      });
}
// src/modules/diffViewProvider.ts

}

export async function showApplyChangesNotification(document: vscode.TextDocument, selectionList: vscode.Selection[], newCodeList: string[]) {
    // Show a pop-up notification with an action button
    const applyChangesAction = 'Apply Changes';

    const result = await vscode.window.showInformationMessage(
        'Do you want to apply the changes to the file?',
        applyChangesAction
    );

    // If the user clicks the 'Apply Changes' button, call the applyDiffChanges function
    if (result === applyChangesAction) {
        await applyDiffChanges(document, selectionList, newCodeList);
    }
}

export function removePlusAndExclamationFromStartIfExists(updatedCode:string) {
// src/webview/pages/components/ErrorModal.tsx

import { Button, Modal, ModalContent, ModalHeader, ModalBody, ModalFooter} from '@nextui-org/react';
import { useAppDispatch } from '../../hooks';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { EasyCodeUser } from '../../../apis/extensionToServerApi';
import { IoCardOutline, IoRocketOutline } from 'react-icons/io5';

interface ErrorModalProps {
  isOpen: boolean;
  errorMessage: string;
  onClose: () => void;
}

export default function ErrorModal({ isOpen, errorMessage, onClose }: ErrorModalProps) {

  return (
    <Modal radius="sm" size={"lg"} placement={"center"} isOpen={isOpen} onClose={onClose}>
// src/chat/phases/diffPhase.ts

					if (diffsList && diffsList.length > 0){


						if (editor) {

							selectionList = [];
							newCodeList = [];
							for (let diffIndex = 0; diffIndex < diffsList.length; diffIndex++){
// src/webview/components/AppNav.tsx

                onClick={() => handleNewTab()}
              />
            </Button>
          </HoverTooltip>
        </NavbarItem>
      </NavbarContent>

      <NavbarContent
        justify="end"
        className="!flex-grow-0 flex-shrink -right-10"
      >
        <NavbarItem>
          <Button
            endContent={<IoRocketOutline className="w-6 h-6" />}
            size="sm"
            color="primary"
            variant="shadow"
            radius="sm"
            className="mt-0"
            onClick={() => setIsUpgradeModalOpen(true)}
          >
            Upgrade
          </Button>
          {/* TODO: */}
        </NavbarItem>
        <NavbarItem>
          <HoverTooltip content={"Account Info"}>
            <Avatar
              as="button"
              showFallback
              src="https://images.unsplash.com/broken"
              onClick={() => handleOpenAccountModal()}
            />
          </HoverTooltip>
        </NavbarItem>
        <AccountModal
// src/chat/agents/readFileContentAgent.ts

export class ReadFileContentAgent extends BaseAgent {

    public selectedCodebaseContent: SelectedCodebaseContent;
    private step: number = 0;
    public filePath: string = '';
    public fileContent: string = '';
    constructor(
        {
        type = ChatAgentType.readFileContent,
        systemMessage = "",
        firstMessagePromptPre = "",
        firstMessagePromptPost = "",
        followUpMessagePromptPre = "",
        followUpMessagePromptPost = "",
        shouldRetrieveInFollowUps = true,
        llmChatHistory = [],
        selectedCodebaseContent = {} as SelectedCodebaseContent,
        }: Partial<ReadFileContentAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory});
        this.selectedCodebaseContent = selectedCodebaseContent;
    }

    public async readFileContentFromMessageContainingFilePath(message:string){
// src/modules/fileSkeleton.ts

});

const appendCallGraphContent = (async function name(call_graph: any[], depth: number, root_path: string) {
    // Recursive only 3 levels deep
    let result = '';
    if (depth > 3) {
        return result;
    }
    for (const cg_node of call_graph) {
        const absoluteFilePath = root_path + cg_node.file_path;
        const content = (await vscode.workspace.fs.readFile(vscode.Uri.file(absoluteFilePath))).toString();
        const scope = cg_node.method.scope;
        if (scope) {
            const lines = content.split('\n');
            const scopedContent = lines.slice(scope[0][0], scope[1][0] + 1).join('\n');
            result += '<call_graph file_path=' + absoluteFilePath + '>\n'
            result += scopedContent + '\n';
            result += '</call_graph>\n'
        }
        depth += 1;
        if (cg_node.method.call_graph?.length > 0) {
            result += await appendCallGraphContent(cg_node.method.call_graph, depth, root_path);
        }
    }
    return result;
})

export const appendFileSkeletonContent = (async function(matches: string[], userPrompt: string) {
// src/sentry/easycodeSentryGlobal.ts

    ownKeys(target) {
        return [...Reflect.ownKeys(target), ...Reflect.ownKeys(sentryStore)];
    },
});

export default globalProxy;
// src/sentry/node-extension-telemetry.ts

import module from 'node:module';
import runtimeProcess from 'node:process';

import * as vscode from 'vscode';
import * as SentryNode from '@sentry/node';
import { ExtraErrorData, RewriteFrames } from '@sentry/integrations';

import { easycode_url } from '../keys';

import type { ExtensionContext } from 'vscode';
import type { TelemetrySender } from 'vscode-1-75';

// extension code is wrapped in a function wrapper
// calculate the wrapper prefix to subtract from stacktrace colum number
const NODE_WRAPPER_PREFIX_LENGTH = module.wrap('__EASYCODE__').indexOf('__EASYCODE__');

export const sentryUncaughtExceptionTelemetrySender: TelemetrySender = {
// src/webview/redux/webviewToExtensionApi.ts

    setModel: builder.mutation<void, { model: string }>({
      query(data) {
        return {
          type: "set-model",
          data,
        };
      },
    }),
    getModel: builder.query<{ model: string }, void>({
      query() {
        return {
          type: "get-model",
        };
      },
    }),
    indexCodebase: builder.mutation<void, void>({
      query() {
        return {
          type: "index-codebase",
        };
      },
      invalidatesTags: ["FileTree", "FileSkeletonData"],
    }),
    indexLocalDirectory: builder.mutation<void, void>({
      query() {
        return {
          type: "index-local-directory",
        };
      },
      invalidatesTags: ["FileTree"],
    }),
    openPrimaryGitIgnoreFile: builder.mutation<void, void>({
      query() {
        return {
          type: "open-primary-gitignore-file",
        };
      },
      invalidatesTags: ["FileTree"],
    }),
    addTab: builder.mutation<{ newTabId: string }, void>({
// src/types/chatMessage.ts

import { SelectedCodebaseContent } from '../apis/extensionToServerApi';
import { ChatCompletionRequestMessage } from 'openai';
import { Agent, ChatAgentType } from './agents';

export interface EasyCodeChatMessage extends ChatCompletionRequestMessage {
    messageIndex?: number;
    easyCodeMetadata?: {
      model?: string,
      modelType?: string,
      feedback?: 'positive' | 'negative',
      isMessageComplete?: boolean,
      useOwnApiKey?: boolean,
      isAskCodebase?: boolean,
      isAskWeb?: boolean,
      useActiveViewContext?: boolean,
      promptRevised?: boolean,
      selectedCodebaseContent?: SelectedCodebaseContent,
      origUserQuery?: string;
      agentType?: ChatAgentType;
      finishedStreaming?: boolean;
    };
  }

  export interface UserAgentChatMessage extends ChatCompletionRequestMessage {
// src/chat/agents/readFileContentAgent.ts

    }
    public async createChatMessages(messages: EasyCodeChatMessage[], model?: string){
        let message = messages[messages.length-1].content
        if (message){
            let fileContent = await this.readFileContentFromMessageContainingFilePath(message);
            this.fileContent = fileContent;
        } else {
            throw 'no message submitted'
        }
    }

    public async *submitChatMessage(model:string) {

        let streamingEasyCodeChatMessage: AgentLLMChatMessage = {
            role: 'assistant',
            content: this.fileContent,
        }

        yield streamingEasyCodeChatMessage as EasyCodeChatMessage;
        throw 'STOPSIGNAL'
    }
}
// src/chat/chats/codebaseExplainChat.ts

import { Chat, ChatType } from "../../types/chat";
import { ChatPhase } from "../../types/chatPhase";
import BaseChat from "./baseChat";
import AskCodebasePhase from "../phases/askCodebasePhase";
import BasePhase from "../phases/basePhase";
import CodebaseExplainPhase from "../phases/codebaseExplainPhase";

export class CodebaseExplainChat extends BaseChat {

    constructor(
        {
            type = ChatType.codebaseExplain,
            phases = [new CodebaseExplainPhase()],
            currentPhaseIndex = 0,
            title = ''
        }: Partial<CodebaseExplainChat> = {}
    ) {
        super({ type, phases, currentPhaseIndex, title });
    }
}

export default CodebaseExplainChat;
// src/webview/components/AppNav.tsx

  const { getUserProfile } =
    useAppRouteLoaderData<"getUserProfile">(layout.id) ?? {};
  const [userProfile, setUserProfile] = useState(
    getUserProfile?.data?.user as EasyCodeUser
  );
  const [isUpgradeModalOpen, setIsUpgradeModalOpen] = useState(false);
  const [isAccountModalOpen, setIsAccountModalOpen] = useState(false);

  const handleNewTab = async () => {
    dispatch(webviewToExtensionApi.endpoints.addTab.initiate());
  };

  useEffect(() => {
    const sentryUser = createSentryUser({ email: userProfile.userEmail });
    SentryReact.setUser(sentryUser);
  }, [userProfile]);

  const handleOpenAccountModal = async () => {
    const updatedUserProfile = await dispatch(
      webviewToExtensionApi.endpoints.getUserProfile.initiate(undefined, {
        forceRefetch: true,
      })
    );
    setUserProfile(updatedUserProfile?.data?.user as EasyCodeUser);
    console.log(updatedUserProfile?.data?.user as EasyCodeUser);
    setIsAccountModalOpen(true);
  };

  return (
    <>
// src/chat/agents/readFileContentAgent.ts

        for (let f = 0; f < filePaths.length; f++){
            let cleanedFilePath = filePaths[f].replace('`', '');
            for (let i = 0; i < this.selectedCodebaseContent.selectedChunkFileNames.length; i++){
                let selectedChunkFilePath = this.selectedCodebaseContent.selectedChunkFileNames[i];
                if (selectedChunkFilePath.includes(cleanedFilePath)){
                    let fileUri = vscode.Uri.joinPath(vscode.Uri.file(this.selectedCodebaseContent.selectedChunkRootIdentifiers[i]), selectedChunkFilePath);
                    let data = await vscode.workspace.fs.readFile(fileUri);
                    return data.toString();
                }
            }
        }

        throw 'file path not in selected codebase chunks';

    }
// src/webview/redux/webviewToExtensionApi.ts

    addTab: builder.mutation<{ newTabId: string }, void>({
      query() {
        return {
          type: "addTab",
        };
      },
      invalidatesTags: ["MessageHistoryList"],
    }),
    deleteTab: builder.mutation<void, { tabIdToDelete: string }>({
      query(data) {
        return {
          type: "deleteTab",
          data,
        };
      },
      invalidatesTags: ["MessageHistoryList"],
    }),
    checkCodebasedIndexed: builder.mutation<void, void>({
      query() {
        return {
          type: "check-codebase-indexed",
        };
      },
    }),
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    getMessageHistoryList: builder.query<
      { messageHistory: { id: string; title: string }[] },
      void
    >({
      query() {
        return {
          type: "get-message-history-list",
        };
      },
      providesTags: ["MessageHistoryList"],
    }),
    getMessagesOrChat: builder.query<
// src/webview/pages/components/AskCodebasePanel.tsx

        <div className="flex flex-row">
          <FileTree node={directoryData.fileTree[0]}
                    isRoot={true}
                    onCheckboxChange={(node, selected) => handleCheckboxChange(node, directoryData.selectedFolderPath, directoryData.isProjectRoot, selected)}/>
          {!directoryData.isProjectRoot &&
            <IoTrashOutline className='w-6 h-6 mt-1 cursor-pointer hover:text-red-500' onClick={(event:any) => handleDeleteDirectory(event, directoryData.selectedFolderPath)} />
          }
        </div>
        )}
        <div style={{marginLeft: '0.125rem'}} className="flex flex-row cursor-pointer hover:text-blue-500" onClick={handleAddDirectory}>
          <IoAddCircleOutline className='ml-5 w-6 h-6 mr-1.5 mb-2' /><span className="">Add Directory</span>
        </div>
        <div style={{marginLeft: '0.125rem'}} className="flex flex-row cursor-pointer hover:text-blue-500" onClick={handleExcludeDirectories}>
          <IoRemoveCircleOutline className='ml-5 w-6 h-6 mr-1.5 mb-2' />
          <span className="">Exclude Directories</span>
// src/chat/phases/defaultPhase.ts

import BasePhase from "./basePhase";

export class DefaultPhase extends BasePhase {

}

export default DefaultPhase;
// src/chat/chats/askWebChat.ts

import { ChatType } from "../../types/chat";
import BaseChat from "./baseChat";
import AskWebPhase from "../phases/askWebPhase";


export class AskWebChat extends BaseChat {

    constructor(
        {
            type = ChatType.askCodebase,
            phases = [new AskWebPhase()],
            currentPhaseIndex = 0,
            title = ''
        }: Partial<AskWebChat> = {}
    ) {
        super({ type, phases, currentPhaseIndex, title });
    }
}

export default AskWebChat;
// src/webview/pages/index.ts

export { default as login } from './data/login';
export { default as tryWithoutAccount } from './data/tryWithoutAccount';
export { default as layout } from './data/layout';
export { default as chatLayout } from './data/chatLayout';
export { default as signup } from './data/signup';
export { default as forgotPassword } from './data/forgotPassword';
export { default as chatTab } from './data/chatTab';
// src/modules/diffViewProvider.ts

}

export async function applyDiffChanges(document: vscode.TextDocument, selectionList: vscode.Selection[], newCodeList: string[]) {
// src/chat/phases/codebaseCallGraphPhase.ts

import CodebaseCallGraphAgent from "../agents/codebaseCallGraphAgent";
import BasePhase from "./basePhase";

export class CodebaseCallGraphPhase extends BasePhase {
    constructor(
        {
			agents = [new CodebaseCallGraphAgent()],
		}: Partial<BasePhase> = {}
    ) {
        super({agents: agents});
    }
}

export default CodebaseCallGraphPhase;
// src/types/webviewToExtensionTypes.ts

const WEBVIEW_TO_EXTENSION_MESSAGES = [
  {
    type: "abort",
    data: {} as {
      reason?: AbortSignal["reason"];
    },
  },
  {
    type: "go-to-code",
    data: {} as {
      text: string;
      isFileName: boolean;
      tabId: string;
      messageIndex: number;
    },
  },
  {
    type: "login",
    data: {} as {
      email?: string | null;
      password?: string | null;
    },
  },
  {
    type: "signup",
    data: {} as {
      email?: string | null;
      password?: string | null;
      role?: string | null;
    },
  },
  {
    type: "forgot-password",
    data: {} as {
      email?: string | null;
    },
  },
  {
    type: "get-model",
  },
  {
    type: "set-model",
    data: {} as {
      model: string;
    },
  },
  {
    type: "select-or-unselect-node",
    data: {} as {
      fileNode: FileTreeNode;
      selected: boolean;
      selectedFolderPath: string;
      isProjectRoot: boolean;
    },
  },
  {
    type: "check-codebase-indexed",
  },
  {
    type: "index-codebase",
  },
  {
// src/webview/pages/components/AskCodebasePanel.tsx

    useEffect(() => {
      if (data?.allDirectoriesFileTree){
        console.log("allDirectoriesFileTree");
        console.log(data);
        //Do a deep copy since original object is readonly
        let newAllDirectoryDatas = JSON.parse(JSON.stringify(data.allDirectoriesFileTree)); // deep copy
        for (let directoryData of newAllDirectoryDatas){
          if (directoryData.fileTree[0] && directoryData.selectedFolderPath){
            let fileTreeStartingFromSelectedFolder = findRootNode(directoryData.fileTree[0], directoryData.selectedFolderPath);
            if (fileTreeStartingFromSelectedFolder){
              const initializedFileTree = initializeNodeState(fileTreeStartingFromSelectedFolder);
              directoryData.fileTree[0] = initializedFileTree;
            }
          }
        }
        setAllDirectoryData(newAllDirectoryDatas);
      }
    }, [data]);

    const handleDeleteDirectory = (event:any, selectedFolderPath: string) => {
// src/modules/diffViewProvider.ts

    // If a match was found, select and reveal the range in the editor
    if (rangeStart !== undefined && rangeEnd !== undefined) {
        let startPos = document.positionAt(rangeStart);
        let endPos = document.positionAt(rangeEnd + 1); // Add 1 to include the last character
        let matchRange = new vscode.Range(startPos, endPos);

        let newSelection = new vscode.Selection(matchRange.start, matchRange.end);
        editor.selection = newSelection;
        editor.revealRange(matchRange);
        return newSelection;
    } else {
        vscode.window.showInformationMessage('No matches found! Attempting to self-correct.');

        throw('No matches found!');
    }
}
// src/helpers/githubCodebaseIndex.ts

        await context.globalState.update(getGhRepoCacheKey({ commit }), true);

        return commit;
    };
};
// src/chat/agents/diffAgent.ts

        }: Partial<DiffAgent> = {}
    ) {
        super({type, systemMessage, firstMessagePromptPre, firstMessagePromptPost, followUpMessagePromptPre, followUpMessagePromptPost, shouldRetrieveInFollowUps, llmChatHistory, functions})
    }
// src/webview/pages/components/Signup.tsx

          value={role.toString()}
          //onValueChange={(value: string) => { setPasswordConfirm(value); }}
        />
        <Dropdown type="listbox">
          <DropdownTrigger>
            <Button fullWidth variant="bordered" className="justify-start">
              {ROLE_OPTIONS.find(({ key }) => key === role)?.label}
// src/webview/components/AppNav.tsx

                    <IoFileTrayFullOutline className="w-6 h-6" />
                  ) : (
                    <IoFileTrayFullOutline className="w-6 h-6" />
                  )}
                </div>
              </HoverTooltip>
            )}
          </ChatHistoryMenuItemConsumer>
        </NavbarItem>
        <NavbarItem>
          <HoverTooltip content="New Chat">
            <Button
              size="sm"
              variant="light"
              radius="sm"
              isIconOnly
              className="relative mt-0.5"
            >
              <IoAddOutline
                className="h-8 w-8 ml-0 pl-0 px-0 mx-0 hover:text-blue-500"
                onClick={() => handleNewTab()}
// src/modules/fileSkeleton.ts

        if (workspaceFolders) {
            let rootPath = workspaceFolders[0].uri.fsPath;
            rootPath = rootPath.split('\\').join('/');
            if (rootPath.charAt(0) == '/'){
                rootPath = rootPath.slice(1);
            }
            if (rootPath.charAt(rootPath.length-1) != '/'){
                rootPath = rootPath + "/";
            }

            const results = await Promise.all(matches.map(async (item) => {
// src/helpers/githubCodebaseIndex.ts

const fetchRefHash = async ({ owner, name, fullRef }: { owner: string, name: string, fullRef: string }) => {
    const encodedOwner = encodeURIComponent(owner);
    const encodedName = encodeURIComponent(name);
    const encodedFullRef = encodeURIComponent(fullRef);

    const res = await fetch(new URL(`/repos/${encodedOwner}/${encodedName}/git/ref/${encodedFullRef}`, GITHUB_API), {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        headers: { Accept: 'application/vnd.github+json', 'X-GitHub-Api-Version': '2022-11-28' },
    });

    if (!res.ok) {
        return null;
    }

    return (await res.json() as any).object.sha as string;
};

const cacheGhRepo = async ({ context, owner, name, commit }: { context: ExtensionContext, owner: string, name: string, commit: string }) => {
// src/modules/codeActionsProvider.ts

    private getExpandedRange(document: TextDocument, range: Range): Range {
        const startLine = Math.max(range.start.line - 3, 0);
        const endLine = Math.min(range.end.line + 3, document.lineCount - 1);
        return new Range(startLine, 0, endLine, document.lineAt(endLine).text.length);
    }
}
// src/chat/phases/askWebPhase.ts

import AskWebAgent from "../agents/askWebAgent";
import { Agent } from "../../types/agents";
import BasePhase from "./basePhase";

export class AskWebPhase extends BasePhase {
    constructor(
        public agents: Agent[] = [new AskWebAgent()],
        public agentIndex: number = 0,
        public agentIterationsLeft: number = 1,
    ) {
        super();
    }
}

export default AskWebPhase;
// src/modules/fileSkeleton.ts

                } else {
                    const fileMethods = fileData.methods;
                    const specifiedMethod = fileMethods.find((item: any) => {
                        const methodString = item.method_name + item.method_parameters.replace(/\s/g, '')
                        return fileStructure.methodName === methodString;
                    });
                    const lines = content.split('\n');
                    const scope = specifiedMethod.scope;
                    const callGraph = await getCallGraphMapMetadata(absoluteFilePath, specifiedMethod.method_name + specifiedMethod.method_parameters)
                    if (callGraph) {
                        result += await appendCallGraphContent(callGraph, 0, rootPath)
                    }
                    if (scope) {
// src/types/webviewToExtensionTypes.ts

  {
    type: "delete-directory",
    data: {} as {
      selectedFolderPath: string;
    },
  },
  {
    type: "index-local-directory",
  },
  {
    type: "open-primary-gitignore-file",
  },
  {
    type: "addTab",
  },
  {
    type: "deleteTab",
    data: {} as {
      tabIdToDelete: string;
    },
  },
  {
    type: "logout",
  },
  {
    type: "login-with-placeholder",
  },
  {
    type: "is-user-logged-in",
  },
  {
    type: "user-profile",
  },
  {
    type: "open-manage-subscription-external-link",
    data: {} as {
      user: EasyCodeUser;
    },
  },
  {
    type: "open-upgrade-external-link",
    data: {} as {
      plan: string;
      user: EasyCodeUser;
    },
  },
  {
    type: "get-message-history-list",
  },
  {
    type: "get-all-directories-file-tree",
  },
  {
    type: "get-messages-or-chat",
    data: {} as {
      tabId?: string | null;
    },
  },
  {
    type: "copy-code",
    data: {} as {
      code: string;
    },
  },
  {
// src/sentry/react-webview-telemetry.ts

export const initializeReactWebviewSentry = () => {
    SentryReact.init({
        enabled: !!process.env.SENTRY_ENABLED,
        release: `${process.env.npm_package_name}@${process.env.npm_package_version}`,
        environment: process.env.NODE_ENV,
        dsn: "https://d95c2e12efc5488cabcbc5c4ddbfa207@o4505094109331456.ingest.sentry.io/4505094523387904",

        sendDefaultPii: true,

        integrations: [
          new SentryReact.BrowserTracing({
            // See docs for support of different versions of variation of react router
            // https://docs.sentry.io/platforms/javascript/guides/react/configuration/integrations/react-router/
            routingInstrumentation: SentryReact.reactRouterV6Instrumentation(
              React.useEffect,
              useLocation,
              useNavigationType,
              createRoutesFromChildren,
              matchRoutes
            ),
          }),
          new SentryReact.Replay({
            maskAllText: false,
            maskAllInputs: false,
            blockAllMedia: false,
          }),
        ],

        // Set tracesSampleRate to 0.01 to capture 1%
// src/types/types.ts

import * as vscode from 'vscode';

export interface FileTreeNode {
	name: string;
	path: string;
	children: FileTreeNode[];
	selected: boolean;
	isFile?: boolean;
}

export interface DirectoryData {
  fileTree: FileTreeNode[];
  isProjectRoot:boolean;
  selectedFolderPath:string;
  rootLabel:string|undefined;
}


export interface ReferenceMapping {
	ReferenceMethodFileMapping: Map<vscode.Uri, vscode.DocumentSymbol>;
	methodName: string;
	methodText: string;
}

export interface CodeEvalHandle {
	run: ({ signal }?: { signal?: AbortSignal }) => void,
}

export interface ExtendedWebviewViewProvider extends vscode.WebviewViewProvider {
	postMessage: (message: any) => void;
  clearCache: () => void;
  createLocalOpenAIClient: (apiKey: string | undefined) => void;
}

export type AuthInfo = {apiKey?: string}
export type ExtensionSettings = {selectedInsideCodeblock?: boolean, copyOnClick?: boolean, model?: string, maxTokens?: number, temperature?: number, userEmail?: string, openAIApiKey?: string, inlineCompletion?: boolean, dataCollection?: boolean, useOwnApiKey?:boolean, usePromptAssistant?:boolean, useActiveViewContext?:boolean}
// src/webview/components/EditorContextMenuListener.tsx

      }
    };

    window.addEventListener('message', messageHandler);

    // Cleanup function
    return () => {
      window.removeEventListener('message', messageHandler);
    };
  }, []);
// src/chat/chats/baseChat.ts

}

export default BaseChat;
// src/webview/components/AppNav.tsx

    <>
      <NavbarContent justify="start" className="flex-wrap gap-y-0">
        {/*
        <NavBarNavLink to="/auth/try">
          Try Without Account
        </NavBarNavLink>
        */}
        <NavBarNavLink to="/auth/signup">Sign Up</NavBarNavLink>
        <NavBarNavLink to="/auth/login">Login</NavBarNavLink>
        <NavBarNavLink to="/auth/forgot-password">
          Forgot Password
        </NavBarNavLink>
      </NavbarContent>
    </>
  );
}

function handleLogoutAndSignUp(navigate: NavigateFunction) {
  store.dispatch(webviewToExtensionApi.endpoints.logout.initiate());
  navigate("/auth/signup");
}

function handleLogout(navigate: NavigateFunction) {
  store.dispatch(webviewToExtensionApi.endpoints.logout.initiate());
  navigate("/auth/login");
}

function AuthenticatedNavbar(isMenuOpen: any) {
  const errorState = useAppSelector((state) => state.errorState);
  const dispatch = useAppDispatch();
  const navigate = useNavigate();
  const { getUserProfile } =
// src/webview/components/EditorContextMenuListener.tsx

    const messageHandler = (event: { data: any; }) => {
      const message = event.data; // The JSON data our extension sent
      switch (message.type) {
// src/sentry/node-extension-telemetry.ts

export const createSentryRewriteFramesIntegration = (context: ExtensionContext) => new RewriteFrames({
    iteratee(frame) {
        const { filename, in_app, colno, lineno } = frame;
        const inCurrentExt = filename ? vscode.Uri.file(filename).path.startsWith(context.extensionUri.path) : in_app;
        const extColno = (colno !== undefined && lineno === 1) ? (colno - NODE_WRAPPER_PREFIX_LENGTH) : colno;

        return {
            ...frame,
            in_app: inCurrentExt,
            colno: inCurrentExt ? extColno : colno,
        };
    }
});

export const initializeExtensionSentry = () => {
// src/runtime.extension.js

/******/ })()
;
//# sourceMappingURL=runtime.extension.js.map// src/helpers/prompt.ts

function createPrompt(agent: Agent, question: string, model: string, selection?: string){
	console.log(agent);
	let messageHistory = [];
	let systemMessageObject = { role: "system", content: agent.systemMessage} as ChatCompletionRequestMessage;
	messageHistory.push(systemMessageObject);
	let userMessageObject: ChatCompletionRequestMessage = { role: "user" };
	let prompt = agent.firstMessagePromptPre + question + agent.firstMessagePromptPost;
	//let prompt = ''
	if (selection) {
		// If there is a selection, add the prompt and the selected text to the search prompt
		if (Globals.getSettings().selectedInsideCodeblock) {
			userMessageObject.content = selection + '\n\n' + prompt;
		} else {
			userMessageObject.content = selection + '\n\n' + prompt;
		}
	} else {
		// Otherwise, just use the prompt if user typed it
		userMessageObject.content = prompt;
	}
	messageHistory.push(userMessageObject);
	return messageHistory;
	/*
// src/chat/chats/baseChat.ts

import { Chat, ChatAction, ChatType } from "../../types/chat";
import { ChatPhase, ChatPhaseType } from "../../types/chatPhase";
import BasePhase from "../phases/basePhase";
import CodebaseDiffImplementationPhase from "../phases/codebaseDiffImplementationPhase";
import CodebaseImplementationPhase from "../phases/codebaseImplementationPhase";
import DiffPhase from "../phases/diffPhase";
import TwoStepCodebaseImplementationPhase from "../phases/twoStepCodebaseImplementationPhase";
import TwoStepCodebasePlanningPhase from "../phases/twoStepCodebasePlanningPhase";

export class BaseChat implements Chat {
// src/chat/agents/readFileContentAgent.ts

}

export default ReadFileContentAgent;
// src/modules/fileSkeleton.ts

export const getCallGraphMapMetadata = (async function(file_path?: string, method_name?: string) {
    const callGraphMapKey = 'callGraphMapKey'
    let callGraphMapString = "";
    const context = await vscode.commands.executeCommand<vscode.ExtensionContext>("getContext");
    const callGraphMapMetadata = context.workspaceState.get(callGraphMapKey) as string;
    if (!callGraphMapMetadata) {
        return callGraphMapString;
    }
    const callGraphMap = new Map<String, Object>(parse(callGraphMapMetadata))
    const workspaceFolders = vscode.workspace.workspaceFolders
    let rootPath = '';
    if (workspaceFolders) {
        rootPath = workspaceFolders[0].uri.fsPath;
        rootPath = rootPath.split('\\').join('/');
        if (rootPath.charAt(0) == '/'){
            rootPath = rootPath.slice(1);
        }
        if (rootPath.charAt(rootPath.length-1) != '/'){
            rootPath = rootPath + "/";
        }
        callGraphMapString = stringify(callGraphMap.get(rootPath))
    }
    if (!file_path){
        return callGraphMapString;
    }
    const callGraphFileMap = new Map<string, object>(Object.entries(parse(callGraphMapString)));
// src/webview/pages/components/ChatLayout.tsx

      <div className="flex flex-row w-full max-w-[80%] items-center gap-2 justify-end transform -translate-y-4">
        <ChatHistoryMenuItemConsumer>
          {({ isHistoryMenuOpen: isHistoryMenuOpen }) => (
          <Select
            ref={selectRef}
            isOpen={isHistoryMenuOpen}
            label=""
            radius="sm"
            disallowEmptySelection={true}
            defaultSelectedKeys={tabId ? new Set([tabId]) : undefined}
            selectedKeys={tabId ? new Set([tabId]) : undefined}
            onSelectionChange={onSelectionChangeHandler}
            className="right-0 max-w-[80%] absolute opacity-0 pointer-events-none"
            classNames={{
              label: "group-data-[filled=true]:-translate-y-20",
              trigger: "min-h-unit-16",
              listboxWrapper: "max-w-[600px] max-h-[32rem] rounded-sm",
            }}
          >
            {(data?.messageHistory || []).slice().reverse().map(msg => (
              <SelectItem key={msg.id} value={msg.id}>
                <div className="flex flex-row gap-x-3 group">
// src/helpers/prompt.ts

import { ChatCompletionRequestMessage } from "openai";
import { Globals } from "../config/globals";
import { Agent } from "../types/agents";


function concatenateHistory(history: string[]) {
	let historyTotal = '';
	for (let i = 0; i < history.length; i++) {
		historyTotal += history[i];
	}
		return historyTotal;
	}

const codeEvalExampleScript: Record<string, string> = {
	bash: '\necho\n',
	batch: '\necho\n',
	java: '\nSystem.out.println();\n',
	node: '\nconsole.log();\n',
	python: '\nprint()\n',
};

function createPrompt(agent: Agent, question: string, model: string, selection?: string){
// src/webview/pages/components/ForgotPassword.tsx

          : <div className="text-danger">Failed to Send Password Reset Email.</div>
        )}
      </div>
    </Form>
  );
}
// src/modules/callGraph.ts

export async function fillingCallGraphData(originalTextChunk: string, callGraphData: any, rootIdentifier: string, fileData: Uint8Array) {
  const data = fileData.toString();
  if (data && data.length > 0){
    const fileText = data.toString();
    const fileIndex = await coordIdxsToCharIdx(rootIdentifier + callGraphData.file_path, callGraphData.method.scope)
    let startCharIndex = parseInt(fileIndex.split(",")[0]);
    let endCharIndex = parseInt(fileIndex.split(",")[1]);
    originalTextChunk += fileText.substring(startCharIndex, endCharIndex);
    return '\n\n<code file_path=' + callGraphData.file_path + ' call_graph=Yes>\n' + originalTextChunk + '\n</code>';
  }
  return originalTextChunk;
}

export function hasParentInChunksMap(chunkIndexMethodsMap: Map<string, any>, methodObject: any) {
// src/webview/pages/components/UpgradeModal.tsx

            <>
              <p>
              To view upgrades, you must first create an account.
              </p>
              <Button radius='sm' color='primary' variant='shadow' onClick={() => handleLogout(navigate)}>
              Sign Up
              </Button>
            </>
          :
            <>
              <>
                <p>
                    Contact us at <b>support@easycode.ai</b> to get more GPT-4 credits.
                </p>
              </>
              {/*
// src/webview/routes/index.ts

export { default as routes } from './routes';
// src/chat/agents/diffAgent.ts

    }

}

export default DiffAgent;
// src/sentry/react-webview-telemetry.ts

import React from 'react';
import { createRoutesFromChildren, matchRoutes, useLocation, useNavigationType } from 'react-router-dom';
import * as SentryReact from "@sentry/react"
import { easycode_url } from '../keys';

export const createSentryUser = ({ email }: { email?: string } = {}): SentryReact.User => ({
    email,
    ip_address: '{{auto}}',
});

export const initializeReactWebviewSentry = () => {
// src/webview/index.tsx

const setDark = () => {
  // next-ui doesn't recognize class names other than 'dark'
  // translate vscode dataset values to dark
  // vscode-dark or vscode-high-contrast => dark mode
  // vscode-light or vscode-high-contrast-light => light mode
  const vscodeThemeKind = document.body.dataset.vscodeThemeKind;
  console.log("THEME KIND: " + document.body.dataset.vscodeThemeKind);
  rootElement.classList.toggle('dark', !!(vscodeThemeKind && ['vscode-dark', 'vscode-high-contrast'].includes(vscodeThemeKind)));
};
setDark();

new MutationObserver(() => {
  setDark();
}).observe(document.body, { attributeFilter: ['data-vscode-theme-kind'], attributes: true });

const router = createHashRouter(routes, {
  future: {
    v7_normalizeFormMethod: true,
  },
});

const root = createRoot(rootElement);
root.render(
// src/webview/components/EditorContextMenuListener.tsx

const EditorContextMenuListener = () => {
  const dispatch = useAppDispatch();

  useEffect(() => {
    //console.log("useEffect hook");
    const messageHandler = (event: { data: any; }) => {
// src/helpers/chatHistory.ts

            truncatedHistory.push({
                ...msg,
                content: newContent,
                easyCodeMetadata: {
                    ...(msg.easyCodeMetadata ?? {}),
                    isMessageComplete: false,
                },
            });
            firstUserMsgAdded = true;
        }
// src/chat/phases/twoStepCodebasePlanningPhase.ts

import CodebaseTwoStepPlanningAgent from "../agents/codebaseTwoStepPlanningAgent";
import { ChatPhaseType } from "../../types/chatPhase";
import BasePhase from "./basePhase";

export class TwoStepCodebasePlanningPhase extends BasePhase {
    constructor(
        {
            type = ChatPhaseType.twoStepCodebasePlanning,
            messageHistory = [],
			agents = [new CodebaseTwoStepPlanningAgent()],
            agentIndex = 0,
            agentIterationsLeft = 1
		}: Partial<BasePhase> = {}
    ) {
        super({type, messageHistory, agents, agentIndex, agentIterationsLeft});
    }
}

export default TwoStepCodebasePlanningPhase;
// src/types/webviewToExtensionTypes.ts

  {
    type: "insert-code",
    data: {} as {
      code: string;
    },
  },
  {
    type: "diff-code",
    data: {} as {
      code: string;
    },
  },
  {
    type: "chat-action",
    data: {} as {
      action: ChatAction;
      tabId: string;
    },
  },
  {
    type: "abort-all-streams",
  },
  {
    type: "send-message",
    data: {} as {
      tabId?: string | null;
      messageIndex?: number | null;
      content?: string | null;
      isAskCodebase?: boolean | null;
      isAskWeb?: boolean | null;
      model?: string | null;
    },
  },
  {
    type: "file-skeleton-data",
  },
] as const;
// src/chat/phases/codebaseDiffImplementationPhase.ts

import BasePhase from "./basePhase";
import CodebaseDiffPerFileImplementationAgent from "../agents/codebaseDiffPerFileImplementationAgent";

export class CodebaseDiffImplementationPhase extends BasePhase {
    constructor(
        {
			agents = [new CodebaseDiffPerFileImplementationAgent()],
		}: Partial<BasePhase> = {}
    ) {
        super({agents: agents});
    }
}

export default CodebaseDiffImplementationPhase;
// src/helpers/githubCodebaseIndex.ts

}): (progress: Progress<{ message?: string, increment?: number }>) => Promise<string> => {
    return async (progress) => {
        let commit: string | undefined | null = context.workspaceState.get<string>(getGhCommitCacheKey({ owner, name, ref }));

        if (!commit) {
            progress.report({ message: 'Fetching repository metadata' });

            // the ref could be a fully specified ref, a branch, or a tag
            const refsToTry = [ref, `heads/${ref}`, `tags/${ref}`];
            while (!commit && refsToTry.length) {
                commit = await fetchRefHash({ owner, name, fullRef: refsToTry.shift()! });
            }

            if (!commit) {
                throw new Error(`Cannot find ${ref} in ${owner}/${name}`);
            }

            await context.workspaceState.update(getGhCommitCacheKey({ owner, name, ref }), commit);
        }

        if (await validateGhRepoCache( { context, commit })) {
            // repo already cached
            return commit;
        }

        progress.report({ message: 'Downloading repository' });
        await cacheGhRepo({ context, owner, name, commit });
        await context.globalState.update(getGhRepoCacheKey({ commit }), true);
// src/webview/tsconfig.json

{
	"experimentalDecorators": true,
	"emitDecoratorMetadata": true,
	"compilerOptions": {
		"module": "ESNext",
		"esModuleInterop": true,
		"target": "ESNext",
		"lib": [
			"ESNext",
			"DOM",
			"DOM.Iterable"
		],
		"jsx": "react-jsx",
		"moduleResolution": "bundler",
		"isolatedModules": true,
		"rootDir": "..",
		"sourceMap": true,
		"strict": true,
		"noUnusedLocals": false,
		"noUnusedParameters": false,
		"noFallthroughCasesInSwitch": true,
	},
}// src/chat/agents/readFileContentAgent.ts

import { Agent, ChatAgentType } from "../../types/agents";
import { AgentLLMChatMessage, EasyCodeChatMessage } from "../../types/chatMessage"
import vscode from 'vscode';
import BaseAgent from "./baseAgent";
import { SelectedCodebaseContent } from "../../apis/extensionToServerApi";

export class ReadFileContentAgent extends BaseAgent {
// src/sentry/easycodeSentryGlobal.ts

const globalProxy = new Proxy(globalThis, {
    get(target, p, receiver) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.get(actualTarget, p, receiver);
    },
    set(target, p, newValue, receiver) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.set(actualTarget, p, newValue, receiver);
    },
    defineProperty(target, p, attributes) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.defineProperty(actualTarget, p, attributes);
    },
    deleteProperty(target, p) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.deleteProperty(actualTarget, p);
    },
    getOwnPropertyDescriptor(target, p) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.getOwnPropertyDescriptor(actualTarget, p);
    },
    has(target, p) {
        const actualTarget = resolveTarget(p, target);
        return Reflect.has(actualTarget, p);
    },
    ownKeys(target) {
// src/webview/pages/components/Signup.tsx

          isLoading={navigation.state !== 'idle'}
        >
          Sign Up
        </Button>

        {(data && 'error' in data) && (
          <div className="text-danger">{data.error?.message}</div>
        )}

      </div>
    </Form>
    </div>
  );
}
// src/webview/pages/data/chatTab.ts

const action: ActionFunction = async ({ request }) => {
  const { tabId, messageIndex, content, isAskCodebase, isAskWeb, model } = Object.fromEntries<FormDataEntryValue>(await request.formData());
  if (!!(tabId && typeof tabId !== 'string') || !!(messageIndex && typeof messageIndex !== 'string') || !!(content && typeof content !== 'string') || !!(isAskCodebase && typeof isAskCodebase !== 'string') || !!(isAskWeb && typeof isAskWeb !== 'string')) {
    // should not happen
    throw new Error('Unexpected type');
  }

  let response = await store.dispatch(webviewToExtensionApi.endpoints.sendMessage.initiate({ tabId: tabId, messageIndex: parseInt(messageIndex), content: content, isAskCodebase: isAskCodebase === 'true', isAskWeb: isAskWeb === 'true', model: typeof model === 'string' ? model : null}));
  if ('error' in response) {
    store.dispatch(errorModal.actions.showError(response.error.message || 'No Error Message'));
  }
  store.dispatch(webviewToExtensionApi.endpoints.getMessageHistoryList.initiate(undefined, {forceRefetch: true}));
  return null;
};
// src/helpers/prompt.ts

};


export { createPrompt };
// src/webview/pages/data/chatTab.ts

};

export default {
  Component: ChatTab,
  loader,
  action,
};
// src/modules/diffViewProvider.ts

    for (let { selection, index } of sortedSelections) {
        let newCode = newCodeList[index];
        let startOffset = document.offsetAt(selection.start);
        let endOffset = document.offsetAt(selection.end);
        let range = new vscode.Range(document.positionAt(startOffset), document.positionAt(endOffset));
        workspaceEdit.replace(document.uri, range, newCode);
    }

    // Apply the workspace edit
    await vscode.workspace.applyEdit(workspaceEdit);
}
// src/webview/pages/components/ChatLayout.tsx

  useEffect(() => {
    console.log("attempt to get messageHistory");
    if (data?.messageHistory.length && data?.messageHistory[data?.messageHistory.length-1].id != prevLastTabId.current) {
      let newTabId = data?.messageHistory[data?.messageHistory.length-1].id;
      navigate(`${newTabId}`);
      console.log("messageHistory");
      console.log(data?.messageHistory);
      //scrollToRight();
    }
    prevLastTabId.current = data?.messageHistory[data?.messageHistory.length-1]?.id;
    console.log("prevDataLength");
    console.log(prevLastTabId.current);
  }, [data]);



  const handleClickOutside = (event:any) => {
    //console.log("handling click");
    if (selectRef.current && !selectRef.current.contains(event.target) && historyMenuButtonRef.current && !historyMenuButtonRef.current.contains(event.target)) {
      console.log(historyMenuButtonRef);
      setHistoryMenuOpen(false);
    }
  };

  // Call scrollToRight after the first render
  useEffect(() => {
// src/runtime.extension.js

/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	
/******/ })()
// src/modules/diffViewProvider.ts

export function removeExclamationFromStartIfExists(updatedCode:string) {
    // Split the string into an array of lines
    const lines = updatedCode.split('\n');

    // Use map to iterate over each line and remove "+ " if it's at the start
    const cleanedLines = lines.map(line => {
      if (line.startsWith('! ')) {
        return line.substring(2); // Remove the first 2 characters "+ "
      }
      return line;
    });

    // Join the array back into a single string with newline characters
    return cleanedLines.join('\n');
}

export async function selectFirstMatchInDocument(searchString: string, editor: vscode.TextEditor) {
// src/modules/codeLensProvider.ts

import vscode from "vscode";
import type { CodeLens, CodeLensProvider, DocumentSymbol, SymbolInformation, ProviderResult, Uri } from "vscode";

const isCodeLensEnabled = () => (
    vscode.workspace.getConfiguration('easycode').get<boolean>('codeLens', true)
);

const findSymbols = async (uri: Uri): Promise<DocumentSymbol[] | null> => {
    const symbols =
        await vscode.commands.executeCommand<ProviderResult<SymbolInformation[] | DocumentSymbol[]>>('vscode.executeDocumentSymbolProvider', uri);
    if (!Array.isArray(symbols) || !('range' in symbols[0])) {
        return null;
    }

    return symbols as DocumentSymbol[];
};

export const createCodeLensProvider = (): CodeLensProvider => ({
// src/helpers/tokenCounters.ts

import { get_encoding } from '@dqbd/tiktoken';
import { ChatCompletionFunctions, ChatCompletionRequestMessage } from 'openai';
import { Globals } from '../config/globals';

const enc = get_encoding("cl100k_base");

export function encodeString(string: string){
    return enc.encode(string);
}

export function decodeToString(encodedString: Uint32Array){
    return enc.decode(encodedString);
}

export function calcMaxAvailableTokens(model: string){
// src/chat/chats/codebaseCallGraphChat.ts

import { Chat, ChatType } from "../../types/chat";
import BaseChat from "./baseChat";
import CodebaseCallGraphPhase from "../phases/codebaseCallGraphPhase";

export class CodebaseCallGraphChat extends BaseChat {

    constructor(
        {
            type = ChatType.codebaseExplain,
            phases = [new CodebaseCallGraphPhase()],
            currentPhaseIndex = 0,
            title = ''
        }: Partial<CodebaseCallGraphChat> = {}
    ) {
        super({ type, phases, currentPhaseIndex, title });
    }
}

export default CodebaseCallGraphChat;
// src/webview/pages/components/ChatLayout.tsx

                <div className="flex flex-row gap-x-3 group">
                  <IoTrashOutline className="h-5 w-5 hover:text-red-500 flex-shrink-0 group-hover:opacity-100 opacity-0"
                            onClick={(event:any) => {
                              event.preventDefault();
                              deleteTab(msg.id)
                            }} />
                  <span className="text-md">{msg.title}</span>
                </div>
              </SelectItem>
            ))}
          </Select>
          )}
        </ChatHistoryMenuItemConsumer>
      </div>
      <Outlet />
    </div>
  );
}
// src/runtime.webview.js

/******/ })()
;
//# sourceMappingURL=runtime.webview.js.map// src/webview/pages/components/UpgradeModal.tsx

        <ModalHeader className="flex flex-col gap-1">Upgrade Your Account</ModalHeader>
        <ModalBody>
          {(userProfile.isPlaceholderAccount == true) ?
            <>
// src/modules/callGraph.ts

    });
    return resultsByTree;
}

export function removeCallerIfNecessary(chunkMethodsMap: Map<number, any>, selectedChunkCallGraphMap: Map<string, any>) {
  const filePathsSet = new Set<string>();
  for (const value of chunkMethodsMap.values()) {
    const filePath = value.file_path + "#L" + value.method.scope[0][0] + "-L" + value.method.scope[1][0];
    filePathsSet.add(filePath);
  }

  for (const key of selectedChunkCallGraphMap.keys()) {
    if (filePathsSet.has(key)) {
      selectedChunkCallGraphMap.delete(key);
    }
  }
}

export async function fillingCallGraphData(originalTextChunk: string, callGraphData: any, rootIdentifier: string, fileData: Uint8Array) {
// src/webview/redux/store.ts

import { configureStore } from '@reduxjs/toolkit';
import { setupListeners } from '@reduxjs/toolkit/query';
import { webviewToExtensionApi } from './webviewToExtensionApi';
import { askCodebaseChecked, askWebChecked, inputText, followUpInputText } from './uiActions';
import { errorModal } from './error';

export const store = configureStore({
  reducer: {
    [webviewToExtensionApi.reducerPath]: webviewToExtensionApi.reducer,
    firstMessageInputText: inputText.reducer,
    followUpMessageInputText: followUpInputText.reducer,
    firstMessageAskCodebaseChecked: askCodebaseChecked.reducer,
    firstMessageAskWebChecked: askWebChecked.reducer,
    errorState: errorModal.reducer,
  },
  middleware: (getDefaultMiddleware) => (
    getDefaultMiddleware().concat(webviewToExtensionApi.middleware)
  ),
});

setupListeners(store.dispatch);

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
// src/chat/chats/baseChat.ts

        }); // Deep copy of phases
        this.currentPhaseIndex = currentPhaseIndex;
        this.title = title;
        this.actions = actions;
    }

    public async *evokeAction(action: ChatAction){
        //Does nothing since this is a base chat and there are no actions currently
        yield {};
    }

    public removeMessageHistoryAfterIndex(messageIndex: number){
        this.phases[this.currentPhaseIndex].removeMessageHistoryFromIndex(messageIndex);
    }

    public calcPhaseMessageIndexAdjustment(){
        let messageIndexAdjustment = 0;
        //Do not count the last (current) phase
        for (let phaseIndex = 0; phaseIndex < this.phases.length-1; phaseIndex++){
            let phase = this.phases[phaseIndex];
            messageIndexAdjustment += phase.messageHistory.length;
        }
        return messageIndexAdjustment;
    }

    public async *submitChatMessage(content:string, model:string) {
// src/webview/pages/components/ChatLayout.tsx

  const { tabId } = useParams<'tabId'>();
  const navigate = useNavigate();
  const selectRef = useRef<HTMLSelectElement>(null);
  console.log(historyMenuButtonRef);

  const onSelectionChangeHandler = useCallback((keys: Selection) => {
    let selectedKey = Array.from(keys)[0];
    console.log(`onSelectionChange from ${tabId} to ${selectedKey}`);
    setHistoryMenuOpen(false);

    if (selectedKey !== tabId) {
      navigate(`${selectedKey}`);
    }
  }, [navigate, tabId]);

  const scrollToRight = () => {
    if (scrollContainerRef.current){
      scrollContainerRef.current.scrollTo(scrollContainerRef.current.scrollWidth, 0);
    }
  };

  const prevLastTabId = useRef(data?.messageHistory[data?.messageHistory.length-1]?.id);

  // Call scrollToRight when a new tab is added
  useEffect(() => {
// src/webview/pages/components/ChatLayout.tsx

  useEffect(() => {
    console.log("messageHistory length: " + data?.messageHistory.length);
    addTab().then(result => {
      if ('data' in result){
        let newTabId = result?.data.newTabId;
        navigate(`${newTabId}`);
      }
    })
  }, []);

  useEffect(() => {
    document.addEventListener("click", handleClickOutside);
    return () => {
      document.removeEventListener("click", handleClickOutside);
    };
  }, []);



  const addTab = async () => {
    return await store.dispatch(webviewToExtensionApi.endpoints.addTab.initiate());
  };

  const deleteTab = (tabIdToDelete: string) => {
    store.dispatch(webviewToExtensionApi.endpoints.deleteTab.initiate({tabIdToDelete})).then(e => {
      let newTabId = data?.messageHistory[data?.messageHistory.length-1].id;
      navigate(`${newTabId}`);
      }
    )
  };

  return (
    <div className="flex flex-col max-h-screen mt-0 pt-0 mb-0 pt-0">
      <div className="flex flex-row w-full max-w-[80%] items-center gap-2 justify-end transform -translate-y-4">
// src/webview/pages/components/Signup.tsx

        {/* this is used to hold the value for the form post */}
        <Input
          className="hidden"
          variant='bordered'
          name="role"
          type="password"
          label="Role"
          value={role.toString()}
// src/helpers/githubCodebaseIndex.ts

const cacheGhRepo = async ({ context, owner, name, commit }: { context: ExtensionContext, owner: string, name: string, commit: string }) => {
    const encodedOwner = encodeURIComponent(owner);
    const encodedName = encodeURIComponent(name);
    const cachePath = vscode.Uri.joinPath(context.globalStorageUri, 'gh', commit);
    const { ok, body } = await fetch(new URL(`/repos/${encodedOwner}/${encodedName}/tarball/${commit}`, GITHUB_API));
    if (!ok || !body) {
        throw new Error('Failed to download repository');
    }

    const tmpPath = vscode.Uri.joinPath(context.globalStorageUri, 'gh', `.tmp-${commit}`);
    await vscode.workspace.fs.createDirectory(tmpPath);
    await stream.promises.pipeline(body, tar.extract({ cwd: tmpPath.fsPath, strip: 1 }));

    await vscode.workspace.fs.createDirectory(cachePath);
    await vscode.workspace.fs.rename(tmpPath, cachePath, { overwrite: true });
};

const validateGhRepoCache = async ({ context, commit }: { context: ExtensionContext, commit: string }) => {
// src/webview/pages/components/ErrorModal.tsx

    <Modal radius="sm" size={"lg"} placement={"center"} isOpen={isOpen} onClose={onClose}>
      <ModalContent>
        <ModalHeader className="flex flex-col gap-1">Error</ModalHeader>
        <ModalBody>
            <>
              <p>
                {errorMessage}
              </p>
            </>
        </ModalBody>
        <ModalFooter>
            <Button color="danger" variant="light" onClick={onClose}>
                Close
            </Button>
          </ModalFooter>
      </ModalContent>
    </Modal>
  );
}
// src/webview/pages/data/layout.ts

  return json<JsonType<'isLoggedIn'>>({ isLoggedIn: { data: { isLoggedIn: false } } });
};

const shouldRevalidate: ShouldRevalidateFunction = () => true;

export default {
  Component: Layout,
  loader,
  shouldRevalidate,
  id: 'layout' as const,
};
// src/types/webviewToExtensionTypes.ts

import { EasyCodeUser } from "../apis/extensionToServerApi";
import { ChatAction } from "./chat";
import { FileTreeNode } from "./types";

interface WebviewChannelMessage {
  readonly type: string;
  readonly id?: string;
  readonly data?: Readonly<Record<string, unknown>>;
  readonly error?: {
    readonly name?: string | null;
    readonly message?: string | null;
    readonly [key: string]: unknown;
  };
}

const WEBVIEW_TO_EXTENSION_MESSAGES = [
// src/modules/codeLensProvider.ts

export const createCodeLensProvider = (): CodeLensProvider => ({
    async provideCodeLenses({ uri }, _token) {
        if (!isCodeLensEnabled()) {
            return null;
        }

        const symbols = await findSymbols(uri);
        if (!symbols?.length) {
            return null;
        }

        const lenses: CodeLens[] = [];
        const findLenses = (symbols: DocumentSymbol[]) => {
// src/webview/css/index.css

/* Must be place before @tailwind base */
@import './vscode-reset.css';

@tailwind base;
@tailwind components;
@tailwind utilities;// src/webview/pages/components/Signup.tsx

              {ROLE_OPTIONS.find(({ key }) => key === role)?.label}
            </Button>
          </DropdownTrigger>
          <DropdownMenu
            disallowEmptySelection
            selectionMode="single"
            aria-label="Role"
            items={ROLE_OPTIONS}
            selectedKeys={[role]}
            disabledKeys={DISABLED_OPTIONS}
            onSelectionChange={(selection: Selection) => { selection !== 'all' && setRole([...selection][0]); }}
          >
            {(item) => {
              const { key, label } = item as { key: string, label: string };
              return <DropdownItem key={key}>{label}</DropdownItem>;
            }}
          </DropdownMenu>
        </Dropdown>

        <Button
          type="submit"
          color="primary"
          isLoading={navigation.state !== 'idle'}
// src/types/chatPhase.ts

import { Agent } from "./agents";
import { UserAgentChatMessage } from "./chatMessage";

export enum ChatPhaseType{
    normal,
    diff,
    codebaseImplementation,
    codebaseDiffImplementation,
    twoStepCodebasePlanning,
    twoStepCodebaseImplementation
  }

export interface ChatPhase {
    type: ChatPhaseType,
    messageHistory: UserAgentChatMessage[],
    agents: Agent[],
    removeMessageHistoryFromIndex: (messageIndex: number) => void,
    submitChatMessage: (content:string, model:string, doNotEchoOrStore?:boolean) => AsyncGenerator<any, any, any>,
  }
// src/modules/callGraph.ts

    }

    const allPaths: any[][] = []; // Store all paths
    extractPaths(callGraphRoot, [], allPaths); // Extract all paths from callGraphRoot

    // Extract methodName value from chunkNodes
    const methodNames: string[] = Array.from(chunkNodes.values())
      .map(chunkMethod => {
        const filePath = chunkMethod.file_path;
        const methodName = chunkMethod.method.method_name
        const scope = chunkMethod.method.scope
        const scopeString = "#L" + scope[0][0] + "-L"+ scope[1][0]
        return filePath + "." + methodName + scopeString
      });

    // Parses the data that needs to be populated for each path
    const resultsByTree: any[] = [];
    allPaths.forEach((path) => {
// src/chat/agents/diffAgent.ts

import { ChatAgentType } from "../../types/agents";
import BaseAgent from "./baseAgent";
import { search_and_replace_schema } from "./function_schemas/function_schemas";

export class DiffAgent extends BaseAgent {
// src/sentry/easycodeSentryGlobal.ts

const KEY = '__SENTRY__' as const;
const sentryStore: { [KEY]: any } = { [KEY]: undefined };

const resolveTarget = <T>(p: string | symbol, target: T) => {
    return p === KEY ? sentryStore : target;
};

// Create a proxy for globalThis for Sentry
// to isolate the global __SENTRY__ variable
const globalProxy = new Proxy(globalThis, {
// src/helpers/githubCodebaseIndex.ts

const validateGhRepoCache = async ({ context, commit }: { context: ExtensionContext, commit: string }) => {
    const isRepoCached = context.globalState.get(getGhRepoCacheKey({ commit }), false);
    if (isRepoCached) {
        try {
            // make sure the cache is present
            await vscode.workspace.fs.stat(getGhRepoCachePath({ context, commit }));
            return true;
        } catch (e) {
            // file not found, ignored
            context.globalState.update(getGhRepoCacheKey({ commit }), undefined);
        }
    }

    return false;
};

export const createCacheGhRepoTask = ({
// src/modules/callGraph.ts

export async function findCallGraphNode(rootIdentifier: string, fileName: string, indices: number[][], charIndex: string) {
    let callGraphMapMetadata 
    if (callGraphCacheMap.has(rootIdentifier + fileName)) {
      callGraphMapMetadata = callGraphCacheMap.get(rootIdentifier + fileName)
    } else {
      callGraphMapMetadata = await getCallGraphMapMetadata(rootIdentifier + fileName);
      callGraphCacheMap.set(rootIdentifier + fileName, callGraphMapMetadata)
    }
    let callGraphNodes: any = []
    if (!callGraphMapMetadata) {
      return callGraphNodes;
    }
    callGraphMapMetadata.methods.forEach((method: any) => {
        const scope = method.scope
        if (!scope) {
            return;
        }
        if (indices[1][0] >= method.scope[0][0] && method.scope[1][0] >= indices[0][0]) {
          callGraphNodes.push({
              file_path: fileName,
              method: method
          })
        }
    })
    return callGraphNodes
}

export function fillMissingMethodsInChunks(chunkNodes: Map<number, any>, callGraphRoot: any): any[] {
// src/modules/callGraph.ts

import {getCallGraphMapMetadata} from './fileSkeleton'
import { coordIdxsToCharIdx } from '../helpers/utils'

function extractCodeDetails(methodIdentifierString: string) {
  const [filePath, rest] = methodIdentifierString.split('@');
  const [methodName, lineScope] = rest.split('#');
  const [startLine, endLine] = lineScope.slice(1).split('-L');
  return {
    filePath: filePath,
    methodName: methodName,
    scope: [parseInt(startLine, 10), parseInt(endLine, 10)]
  };
}


export async function resolveCallerStructure(callGraphMapMetadata: any) {
  const callGraphMapdata = new Map<string, any>(Object.entries(callGraphMapMetadata));
  for (const methodsObject of callGraphMapdata.values()) {
    if (!methodsObject || !methodsObject.methods || methodsObject.methods.length == 0) {
      continue
    }
    resolveCallGraph(methodsObject.methods, callGraphMapdata)
  }
}

function resolveCallGraph(methods: any[], callGraphMapdata: Map<string, any>) {
// src/webview/hooks/index.ts

export * from './redux';
// src/chat/chats/baseChat.ts

    ) {
        this.type = type;
        this.phases = phases.map(phase => {
            if (phase.type == ChatPhaseType.normal){
				return new BasePhase(phase);
			} else if (phase.type == ChatPhaseType.diff){
				return new DiffPhase(phase as DiffPhase);
			} else if (phase.type == ChatPhaseType.twoStepCodebasePlanning){
				return new TwoStepCodebasePlanningPhase(phase as TwoStepCodebasePlanningPhase);
			} else if (phase.type == ChatPhaseType.twoStepCodebaseImplementation){
                return new TwoStepCodebaseImplementationPhase(phase as TwoStepCodebaseImplementationPhase);
            } else if (phase.type == ChatPhaseType.codebaseImplementation){
                return new CodebaseImplementationPhase(phase as CodebaseImplementationPhase);
            } else if (phase.type == ChatPhaseType.codebaseDiffImplementation){
                return new CodebaseDiffImplementationPhase(phase as CodebaseDiffImplementationPhase);
            } else {
                return phase;
            }
        }); // Deep copy of phases
// src/webview/pages/components/Signup.tsx

export default function Signup() {
  const [role, setRole] = useState<Key>('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [passwordConfirm, setPasswordConfirm] = useState('');
  let fetcher = useFetcher();

  const data = useAppActionData<'signup'>()?.signup;
  const navigation = useNavigation();

  return (
    <div>
// src/helpers/chatHistory.ts

        if (
            ((truncatedHistoryLength - msgLength) >= targetLength)
            || (msg.role !== 'user')
            || (!msg.content?.length)
            || ((truncatedHistoryLength - encodeString(msg.content).length) >= targetLength)
        ) {
            // remove the entire message if
            // 1. Removing this message partially doesn't achieve the target prompt length
            // 2. This message is not a user message
            // 3. This message is empty
            // 4. Removing this message's entire content doesn't achieve the target prompt length, i.e. token_budget <= msg_overhead

            truncatedHistoryLength -= msgLength;
        } else {
// src/runtime.webview.js

/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = globalThis["webpackChunkchatgpt_gpt4_gpt3_vscode"] = globalThis["webpackChunkchatgpt_gpt4_gpt3_vscode"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
// src/webview/index.tsx

root.render(
  // <StrictMode>
    <SentryReact.ErrorBoundary fallback={<p>An error has occurred</p>}>
      <ReduxProvider store={store}>
        <NextUIProvider>
          <div className="flex flex-col h-screen w-screen text-foreground bg-background overflow-x-hidden">
            <EditorContextMenuListener />
            <RouterProvider router={router} future={{ v7_startTransition: true }} fallbackElement={<Spinner label="Loading" className="m-auto" />} />
          </div>
        </NextUIProvider>
      </ReduxProvider>
    </SentryReact.ErrorBoundary>
  // </StrictMode>,
);
// src/webview/pages/components/UpgradeModal.tsx

              */}
            </>

          }
        </ModalBody>
        <ModalFooter>
            <Button color="danger" variant="light" onClick={onClose}>
                Close
            </Button>
          </ModalFooter>
      </ModalContent>
    </Modal>
  );
}
// src/runtime.webview.js

/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
// src/helpers/dataCollection.ts

export function createDataCollectionLogObject(stringifiedMessageHistory: string, model?: string, feedback?: string) {
    let logObject = {
      model: model ?? Globals.getSettings().model,
      feedback: feedback || "",
      chatString1: "",
      chatString2: "",
      chatString3: "",
      chatString4: "",
      chatString5: "",
      chatString6: "",
      chatString7: "",
      chatString8: "",
  };

  let stringifiedMessageHistoryChunks = splitStringIntoChunks(stringifiedMessageHistory, 32000);
  //really really stupid manual way of assigning fields due to logging object limitations
  stringifiedMessageHistoryChunks.forEach((chunk:string, index:number) => {
// src/runtime.extension.js

/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
// src/chat/chats/baseChat.ts

    public async *submitChatMessage(content:string, model:string) {
        try {
			for await (let { message, messageIndex } of this.phases[this.currentPhaseIndex].submitChatMessage(content, model)) {
				messageIndex = this.calcPhaseMessageIndexAdjustment() + messageIndex;
                yield { message, messageIndex };
			}
		} catch (error: any) {
            throw error;
        }
    }

}
// src/helpers/tokenCounters.ts

/**
 * Only accurate for OpenAI models
 * based on https://github.com/openai/openai-cookbook/blob/4fd2b1a6d29d76dcdb3ae65ac12b1a71253d65b6/examples/How_to_count_tokens_with_tiktoken.ipynb
 */
export function countMessageTokens(message: ChatCompletionRequestMessage) {
    // message prefix 3 tokens, suffix 3 tokens
    let sum = 3 + 3;
    sum += enc.encode(message.role).length;
    if (message.name) {
        sum += enc.encode(message.name).length;
        // name consumes 1 additional token
        sum += 1;
    }
    if (message.content) {
        sum += enc.encode(message.content).length;
    }
    if (message.function_call?.name) {
        sum += enc.encode(message.function_call.name).length;
        sum += 1;
    }
    if (message.function_call?.arguments) {
        sum += enc.encode(message.function_call.arguments).length;
        sum += 1;
    }

    return sum;
}

/**
// src/helpers/chatHistory.ts

        } else {
            // otherwise, partially truncate this message

            const tokensToRemove = truncatedHistoryLength - targetLength;
            const tokens = encodeString(msg.content);
            const truncatedTokens = tokens.subarray(tokensToRemove);

            let newContent = new TextDecoder().decode(decodeToString(truncatedTokens));
            const newContentTrimmed = newContent.trim();

            let newContentLength = truncatedTokens.length;
            const newContentTrimmedLength = encodeString(newContentTrimmed).length;

            if (newContentTrimmedLength <= newContentLength) {
                newContent = newContentTrimmed;
                newContentLength = newContentTrimmedLength;
            }

            const tokensSaved = tokens.length - newContentLength;
            truncatedHistoryLength -= tokensSaved;
            truncatedHistory.push({
// src/runtime.extension.js

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
// src/webview/components/index.ts

export { default as AppNav } from './AppNav';
export { default as CommandLink } from './CommandLink';
export { default as ExternalLink } from './ExternalLink';
// src/webview/pages/components/FileTree.tsx

          className="ml-0 my-0 px-0 py-0" 
          startContent={<Checkbox className="pl-1 my-0 py-0" key={node.path} value={node.path} isSelected={node.selected} onChange={(event) => handleCheckboxChange(event, node)}>{node.name}</Checkbox>}>
            <div className="ml-12 my-0 py-0 flex flex-col">
            {node.children?.map(childNode => (
                <FileTree key={childNode.path} node={childNode} isRoot={false} onCheckboxChange={onCheckboxChange}/>
            ))}
            </div>
        </AccordionItem>
    </Accordion>
  );
};
// src/runtime.extension.js

/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"runtime": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
// src/helpers/chatHistory.ts

import { TextDecoder } from "node:util";
import { EasyCodeChatMessage } from "../types/chatMessage";
import { countMessageTokens, decodeToString, encodeString } from "./tokenCounters";


export function messageNumberToIndex(chatHistory: EasyCodeChatMessage[], messageNumber: number) {
    const tabMsgHistory = chatHistory;
    let counter = 0;
    const idx = tabMsgHistory.findIndex(({ role }) => {
        if (role === 'user') {
            counter++;
        }
        return counter === (messageNumber + 1);
    });
    return (idx < 0 ? tabMsgHistory.length : idx) - 1;
}

// create a copy of message history with history up to message number
export function sliceMessageHistory(chatHistory: EasyCodeChatMessage[], messageNumber: number) {
    const tabMsgHistory = chatHistory;
    return tabMsgHistory.slice(0, messageNumberToIndex(chatHistory, messageNumber) + 1);
}
/**
// src/runtime.webview.js

/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
// src/webview/pages/components/AccountModal.tsx

import { Button, Modal, ModalContent, ModalHeader, ModalBody, ModalFooter} from '@nextui-org/react';
import { EasyCodeUser } from '../../../apis/extensionToServerApi';
import { IoBatteryHalf, IoPersonOutline, IoRocketOutline } from 'react-icons/io5';

interface AccountModalProps {
  isOpen: boolean;
  userProfile: EasyCodeUser;
  setIsUpgradeModalOpen: any;
  onClose: () => void;
}

export default function AccountModal({ isOpen, userProfile, setIsUpgradeModalOpen, onClose }: AccountModalProps) {
    console.log(userProfile);
    return (
    <Modal radius="sm" backdrop={"blur"} size={"lg"} placement={"center"}isOpen={isOpen} onClose={onClose}>
      <ModalContent>
        <ModalHeader className="flex flex-col gap-1">Your Account Info</ModalHeader>
        <ModalBody>
            <div className="flex flex-row"><IoPersonOutline className="h-6 w-6 mr-2" /><span className='text-md'>{'Email: ' + (userProfile?.isPlaceholderAccount == true ? 'Trial Account' : userProfile?.userEmail)}</span></div>
            <p>
              <div className="flex flex-row"><IoBatteryHalf className="h-6 w-6 mr-2" /><span className='text-md'>Rate Limits:</span></div>
// src/runtime.webview.js

/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
// src/webview/helpers/LazyHighlighter.tsx

import { atomOneDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';
import SyntaxHighlighter from 'react-syntax-highlighter';
import hljs from 'highlight.js';

function LazyHighlighter({ language, value }: {language:any, value:any }) {
  //const ref = useRef<HTMLDivElement>(null);

  if (!language){
    const result = hljs.highlightAuto(value);
    language = result.language;
  }

  return (
    <div>
      {(
        <SyntaxHighlighter language={language} style={atomOneDark}>
          {value}
        </SyntaxHighlighter>
      )}
    </div>
  );
}

export default LazyHighlighter;
// src/webview/index.tsx

import { NextUIProvider, Spinner } from '@nextui-org/react';

import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { Provider as ReduxProvider } from 'react-redux';
import { createHashRouter, RouterProvider } from 'react-router-dom';
import { store } from './redux/store';
import { routes } from './routes';
import { EditorContextMenuListener } from './components/EditorContextMenuListener';
import * as SentryReact from "@sentry/react"
import {
  initializeReactWebviewSentry,
} from '../sentry/react-webview-telemetry';

import './css/index.css';

initializeReactWebviewSentry();

const rootElement = document.getElementById('root') as HTMLDivElement;

const setDark = () => {
// src/webview/unicons.d.ts

declare module '@iconscout/react-unicons';
declare module '@iconscout/react-unicons-thinline';
// src/webview/pages/components/Login.tsx

import { Button, Input } from '@nextui-org/react';
import { useState } from 'react';
import { Form, useNavigation } from 'react-router-dom';
import { useAppActionData } from '../../hooks';

export default function Login() {
// src/types/webviewToExtensionTypes.ts

] as const;

const EXTENSION_TO_WEBVIEW_MESSAGES = [
  {
    type: "" as "response" | "response-streaming",
    data: {} as WebviewChannelMessage["data"],
  },
  {
    type: "" as "response" | "response-streaming",
    error: {} as WebviewChannelMessage["error"],
  },
  {
    type: "new-tab",
    data: {} as WebviewChannelMessage["data"],
  },
  {
    type: "contextMenuOptionSelected",
    data: {} as {
      option?: string | null;
      input?: string | null;
      selection?: string | null;
    },
  },
] as const;

export type WebviewToExtensionMessage = WebviewChannelMessage &
  (typeof WEBVIEW_TO_EXTENSION_MESSAGES)[number];
export type ExtensionToWebviewMessage = WebviewChannelMessage &
  (typeof EXTENSION_TO_WEBVIEW_MESSAGES)[number];
export type ValidWebviewMessage<T extends Partial<WebviewChannelMessage> = {}> =
  Readonly<
    { readonly type: string; readonly id: string } & Extract<
      WebviewToExtensionMessage | ExtensionToWebviewMessage,
      T
    >
  >;
// src/webview/pages/data/signup.ts

const action: ActionFunction = async ({ request }) => {
  const { email, password, passwordConfirm, role } = Object.fromEntries<FormDataEntryValue>(await request.formData());

  if (!!(email && typeof email !== 'string') || !!(password && typeof password !== 'string') || !!(passwordConfirm && typeof passwordConfirm !== 'string') || !!(role && typeof role !== 'string')) {
    // should not happen
    throw new Error('Unexpected type');
  }

  if (password !== passwordConfirm) {
    console.log(password);
    console.log(passwordConfirm);
    console.log(role);
    return json<JsonType<'signup'>>({ signup: { error: {message: 'Passwords do not match!'}} });
  }

  const result = await store.dispatch(webviewToExtensionApi.endpoints.signup.initiate({ email, password, role }));
  if ('error' in result) {
    return json<JsonType<'signup'>>({ signup: result });
  } else {
    return redirect('/chat');
  }
};

export default {
  Component: Signup,
  action,
};
// src/webview/pages/data/layout.ts

const loader: LoaderFunction = async ({ request }) => {
  const isLoggedInPromise = store.dispatch(webviewToExtensionApi.endpoints.isLoggedIn.initiate(undefined, {
    forceRefetch: true,
  }));
  const { data: { isLoggedIn = false } = {} } = await isLoggedInPromise;
  isLoggedInPromise.unsubscribe();

  if (isLoggedIn && new URL(request.url).pathname.startsWith('/auth')) {
    return redirect('/chat');
  }

  if (!isLoggedIn && !new URL(request.url).pathname.startsWith('/auth')) {
    return redirect('/auth');
  }

  // fetch profile to confirm access
  if (isLoggedIn) {
    const userProfilePromise = store.dispatch(webviewToExtensionApi.endpoints.getUserProfile.initiate());
    const profile = await userProfilePromise;
    userProfilePromise.unsubscribe();

    if (profile.status === QueryStatus.rejected || !profile.data?.user) {
      // TODO: trigger logout
      return redirect('/auth');
    }

    return json<JsonType<'isLoggedIn' | 'getUserProfile'>>({
      isLoggedIn: { data: { isLoggedIn } },
      getUserProfile: { data: profile.data },
    });
  }

  return json<JsonType<'isLoggedIn'>>({ isLoggedIn: { data: { isLoggedIn: false } } });
// src/helpers/chatHistory.ts

        }
    }

    if (truncatedHistoryLength > targetLength) {
        throw new Error(`Unable to truncate message to ${targetLength} tokens, min. tokens required ${truncatedHistoryLength}`);
    }

    return truncatedHistory;
}
// src/webview/pages/components/AccountModal.tsx

              <IoRocketOutline className="w-6 h-6" />Upgrade
            </Button>
        </ModalBody>
        <ModalFooter>
            <Button color="danger" variant="light" onClick={onClose}>
                Close
            </Button>
          </ModalFooter>
      </ModalContent>
    </Modal>
  );
}
// src/webview/pages/components/FileTree.tsx

    isRoot ?

    <Accordion defaultExpandedKeys={['root']} isCompact fullWidth={false} className="ml-0 my-0 px-0 py-0">
        <AccordionItem key="root" classNames={{indicator: "order-first -rotate-180 mr-0 pr-0"}} className="ml-0 my-0 px-0 py-0" startContent={<Checkbox className="pl-1 my-0 py-0" key={node.path} value={node.path} isSelected={node.selected} onChange={(event) => handleCheckboxChange(event, node)}>{node.name}</Checkbox>}>
            <div className="ml-12 my-0 py-0 flex flex-col">
            {node.children?.map(childNode => (
                <FileTree key={childNode.path} node={childNode} isRoot={false} onCheckboxChange={onCheckboxChange}/>
            ))}
            </div>
        </AccordionItem>
    </Accordion>
    :

    <Accordion isCompact fullWidth={false} className="-ml-6 my-0 px-0 py-0">
        <AccordionItem 
          // setting trigger to my-0 ensures there is no extra spacing.
          classNames={{trigger: "my-0, py-0", indicator: "order-first -rotate-180 mr-0 pr-0"}} 
          className="ml-0 my-0 px-0 py-0" 
// src/webview/redux/error.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

const errorState = {
  error: false,
  message: ''
};

const errorModalSlice = createSlice({
  name: 'errorModal',
  initialState: errorState,
  reducers: {
    showError: (state, action: PayloadAction<string>) => {
      state.error = true;
      state.message = action.payload;
      return state;
    },
    clearError: (state) => {
      state.error = false;
      state.message = '';
      return state;
    },
    // other reducers...
  },
});

// Export as an object
export const errorModal = {
  reducer: errorModalSlice.reducer,
  actions: errorModalSlice.actions,
};
// src/webview/pages/components/UpgradeModal.tsx

import { Button, Modal, ModalContent, ModalHeader, ModalBody, ModalFooter} from '@nextui-org/react';
import { useAppDispatch } from '../../hooks';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { EasyCodeUser } from '../../../apis/extensionToServerApi';
import { IoCardOutline, IoRocketOutline } from 'react-icons/io5';
import { NavigateFunction, useNavigate } from 'react-router-dom';
import { store } from '../../redux/store';

interface UpgradeModalProps {
  isOpen: boolean;
  userProfile: EasyCodeUser;
  onClose: () => void;
}

export default function UpgradeModal({ isOpen, userProfile, onClose }: UpgradeModalProps) {
  let dispatch = useAppDispatch();
  const navigate = useNavigate();

  function handleLogout(navigate: NavigateFunction) {
    store.dispatch(webviewToExtensionApi.endpoints.logout.initiate());
    navigate('/auth/signup');
  }

  return (
    <Modal radius="sm" backdrop={"blur"} size={"lg"} placement={"center"} isOpen={isOpen} onClose={onClose}>
      <ModalContent>
        <ModalHeader className="flex flex-col gap-1">Upgrade Your Account</ModalHeader>
// src/webview/css/vscode-reset.css

/* Undo some vscode injected styles */

body,
img,
video,
a,
code,
blockquote,
kbd,
a code
{
  all: revert;
}

a:hover {
  color: inherit;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
  outline: inherit;
  outline-offset: inherit;
}

body {
  background-color: var(--vscode-editor-background);
  width: 100vw;
  height: 100vh;
}

html {
  font-size: var(--vscode-font-size);
}

.no-overflow {
  overflow: unset !important;
}// src/helpers/tokenCounters.ts

/**
 * Estimate input token usage for each function definition
 * The estimation will be off by a few tokens from the actual usage.
 * There is no official documentation on how function definitions should be counted,
 * see https://github.com/openai/openai-cookbook/issues/500
 */

export function countFunctionDefinitionTokens(functions: ReadonlyArray<ChatCompletionFunctions>) {
    return functions.reduce((agg, curr) => agg + enc.encode(JSON.stringify(curr)).length, 0);
}

export function countMessageHistoryTokens(messageHistory: ChatCompletionRequestMessage[], functions: ReadonlyArray<ChatCompletionFunctions>) {
    const msgTokenCount = messageHistory.reduce((agg, curr) => agg + countMessageTokens(curr), 0);
    const funcTokenCount = countFunctionDefinitionTokens(functions);

    return msgTokenCount + funcTokenCount;
}
// src/webview/components/CommandLink.tsx

export default function CommandLink({ command, args, showAnchorIcon = false, children }: CommandLinkProps) {
  const anchorRef = useRef<HTMLAnchorElement>(null);
  const serializedArgs = useMemo(() => (
    args !== undefined ? encodeURIComponent(JSON.stringify(args)) : undefined
  ), [args]);
  const uri = useMemo(() => {
    let commandUri = `command:${command}`;
    if (serializedArgs !== undefined) {
      commandUri += `?${serializedArgs}`;
    }
    return commandUri;
  }, [command, serializedArgs]);
  const onPressHandler = useCallback(() => {
    anchorRef.current?.click();
  }, []);

  return (
    <>
      <span className="w-full text-lg text-white hover:text-blue-500 cursor-pointer" onClick={onPressHandler}>{children}</span>
      {/* create another anchor tag to hold the uri, directly using Link's href doesn't work */}
      {createPortal(<a ref={anchorRef} className="hidden" href={uri} />, document.body)}
    </>
  );
}
// src/webview/components/ChatHistoryMenuItemContext.tsx

import React, { Dispatch, RefObject, SetStateAction } from 'react';

const ChatHistoryMenuItemContext = React.createContext({
    isHistoryMenuOpen: false,
    setHistoryMenuOpen: (() => {}) as Dispatch<SetStateAction<boolean>>,
    historyMenuButtonRef: React.createRef<HTMLDivElement>(),
  });

export const ChatHistoryMenuItemProvider = ChatHistoryMenuItemContext.Provider;
export const ChatHistoryMenuItemConsumer = ChatHistoryMenuItemContext.Consumer;

export default ChatHistoryMenuItemContext;
// src/webviewProvider/Webview.tsx

            <meta charSet="UTF-8" />
            <meta name="viewport" content="width=device-width,initial-scale=1" />
            <script type="module" src={webview.asWebviewUri(webpackRuntime).toString()} />
            <script type="module" src={webview.asWebviewUri(jsVendor).toString()} />
            <script type="module" src={webview.asWebviewUri(jsEntry).toString()} />
            <link rel="stylesheet" href={webview.asWebviewUri(stylesheet).toString()} />
            <title />
        </head>
        <body>
        <div id="root" data-icon-uri={iconUri.toString()} />
        </body>
        </html>
    );
}

export const renderWebview = (params: WebviewProps) => {
    // use static markup because vscode modifies the html
    return renderToStaticMarkup(<Webview {...params} />);
};
// src/webview/pages/data/forgotPassword.ts

import { json } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import type { JsonType } from '../../routes/types';
import ForgotPassword from '../components/ForgotPassword';
import type { ActionFunction } from '@remix-run/router';

const action: ActionFunction = async ({ request }) => {
  const { email } = Object.fromEntries<FormDataEntryValue>(await request.formData());

  if (!!(email && typeof email !== 'string')) {
    // should not happen
    throw new Error('Unexpected type');
  }

  const result = await store.dispatch(webviewToExtensionApi.endpoints.forgotPassword.initiate({ email }));
  console.log(result);
  if ('error' in result) {
    return json<JsonType<'forgotPassword'>>({ forgotPassword: result });
  } else {
    return json<JsonType<'forgotPassword'>>({ forgotPassword: result });
  }
};

export default {
  Component: ForgotPassword,
  action,
};
// src/webview/pages/components/ForgotPassword.tsx

import { Button, Input } from '@nextui-org/react';
import { useState } from 'react';
import { Form } from 'react-router-dom';
import { useAppActionData } from '../../hooks';

export default function ForgotPassword() {
  const [email, setEmail] = useState('');

  const data = useAppActionData<'forgotPassword'>()?.forgotPassword;
  //console.log("data: ");
  //console.log("data.data?.success: ", data?.data?.success);
  return (
    <Form replace method="POST">
      <div className="flex flex-col gap-y-4 items-start px-6 w-64">
        <Input
          variant='bordered'
          name="email"
          type="email"
          label="Email"
          value={email}
          onValueChange={(value: string) => { setEmail(value); }}
        />

        <Button type="submit" color="primary">Get Password Reset Link</Button>
        {(data) && (
          data.data?.success
          ? <div className="text-success">Password Reset Email Sent.</div>
          : <div className="text-danger">Failed to Send Password Reset Email.</div>
// src/helpers/dataCollection.ts

  stringifiedMessageHistoryChunks.forEach((chunk:string, index:number) => {
      if (index == 0){
          logObject.chatString1 = chunk;
      } else if (index == 1){
          logObject.chatString2 = chunk;
      } else if (index == 2){
          logObject.chatString3 = chunk;
      } else if (index == 3){
          logObject.chatString4 = chunk;
      } else if (index == 4){
          logObject.chatString5 = chunk;
      } else if (index == 5){
          logObject.chatString6 = chunk;
      } else if (index == 6){
          logObject.chatString7 = chunk;
      } else if (index == 7){
          logObject.chatString8 = chunk;
      }
    });

    return logObject;
  }
// src/webview/pages/components/Layout.tsx

import { Outlet, ScrollRestoration } from 'react-router-dom';
import { AppNav } from '../../components';
import { useRef, useState } from 'react';
import { ChatHistoryMenuItemProvider } from '../../components/ChatHistoryMenuItemContext';
import React from 'react';

export default function Layout() {

  const [isMenuOpen, setMenuOpen] = useState(false);
  const historyMenuButtonRef = useRef<HTMLDivElement>(null);

  return (
    <>
      <ChatHistoryMenuItemProvider value={{ isHistoryMenuOpen: isMenuOpen, setHistoryMenuOpen: setMenuOpen, historyMenuButtonRef: historyMenuButtonRef}}>
      <AppNav />
      <main className="flex-grow">
        <Outlet />
      </main>
      </ChatHistoryMenuItemProvider>
      <ScrollRestoration />
    </>
  );
}
// src/webview/components/CommandLink.tsx

import { Link } from '@nextui-org/react';
import { useCallback, useMemo, useRef } from 'react';
import { createPortal } from 'react-dom';
import type { ReactNode } from 'react';

export interface CommandLinkProps {
  command: string;
  args?: unknown;
  showAnchorIcon?: boolean,
  children?: ReactNode;
}

export default function CommandLink({ command, args, showAnchorIcon = false, children }: CommandLinkProps) {
// src/webview/pages/data/tryWithoutAccount.ts

import { json, redirect } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import TryWithoutAccount from '../components/TryWithoutAccount';
import type { JsonType } from '../../routes/types';
import type { ActionFunction } from '@remix-run/router';

const action: ActionFunction = async () => {
  const result = await store.dispatch(webviewToExtensionApi.endpoints.loginWithPlaceholder.initiate());
  if ('error' in result) {
    return json<JsonType<'loginWithPlaceholder'>>({ loginWithPlaceholder: result });
  } else {
    return redirect('/chat');
  }
};

export default {
  Component: TryWithoutAccount,
  action,
};
// src/helpers/dataCollection.ts

import { Globals } from "../config/globals";


function splitStringIntoChunks(str: string, chunkSize: number) {
    const chunks = [];
    for (let i = 0; i < str.length; i += chunkSize) {
        chunks.push(str.slice(i, i + chunkSize));
    }
    return chunks;
}

export function createDataCollectionLogObject(stringifiedMessageHistory: string, model?: string, feedback?: string) {
// src/webview/pages/components/Login.tsx

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const data = useAppActionData<'login'>()?.login;
  const navigation = useNavigation();

  return (
    <Form replace method="POST" className="flex flex-col gap-y-4 items-start px-6 w-64">
      <Input
        variant='bordered'
        name="email"
        type="email"
        label="Email"
        value={email}
        onValueChange={(value: string) => { setEmail(value); }}
      />
      <Input
        variant='bordered'
        name="password"
        type="password"
        label="Password"
        value={password}
        onValueChange={(value: string) => { setPassword(value); }}
      />

      <Button
        type="submit"
        color="primary"
        isLoading={navigation.state !== 'idle'}
      >
        Login
      </Button>

      {(data && 'error' in data) && (
        <div className="text-danger">{data.error?.message}</div>
      )}
    </Form>
  );
}
// src/webview/routes/routes.tsx

import { createRoutesFromElements, redirect, Route } from 'react-router-dom';
import { chatLayout, chatTab, forgotPassword, layout, login, signup, tryWithoutAccount } from '../pages';

// TODO: error boundary
const routes = createRoutesFromElements(
  <Route path="/" {...layout}>
    <Route index loader={() => redirect('chat')} />

    <Route path="/auth">
      <Route index loader={() => redirect('login')} />
      <Route path="signup" {...signup} />
      <Route path="login" {...login} />
      <Route path="forgot-password" {...forgotPassword} />
      <Route path="try" {...tryWithoutAccount} />
    </Route>

    <Route path="/chat">
      <Route {...chatLayout}>
        <Route index loader={() => redirect('new')} />
        <Route path="new" element={<div></div>} />
        <Route path=":tabId" {...chatTab} />
      </Route>
    </Route>
  </Route>,
);

export default routes;
// src/webview/pages/data/signup.ts

import { json, redirect } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import Signup from '../components/Signup';
import type { JsonType } from '../../routes/types';
import type { ActionFunction } from '@remix-run/router';

const action: ActionFunction = async ({ request }) => {
// src/webview/pages/data/chatTab.ts

import { json } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import ChatTab from '../components/ChatTab';
import type { JsonType } from '../../routes/types';
import type { ActionFunction } from '@remix-run/router';
import type { LoaderFunction } from 'react-router-dom';
import { useAppDispatch } from '../../hooks';
import { errorModal } from '../../redux/error';

const loader: LoaderFunction = async ({ params }) => {
  const { tabId } = params;

  const messagesPromise = store.dispatch(webviewToExtensionApi.endpoints.getMessagesOrChat.initiate({ tabId }));
  const messages = await messagesPromise;
  messagesPromise.unsubscribe();

  const { data, error } = messages;
  return json<JsonType<'getMessagesOrChat'>>({ getMessagesOrChat: { data, error } });
};

const action: ActionFunction = async ({ request }) => {
// src/webview/pages/data/layout.ts

import { QueryStatus } from '@reduxjs/toolkit/query';
import { json, redirect } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import Layout from '../components/Layout';
import type { JsonType } from '../../routes/types';
import type { LoaderFunction , ShouldRevalidateFunction } from 'react-router-dom';

const loader: LoaderFunction = async ({ request }) => {
// src/webview/vscode.ts

import type { ValidWebviewMessage } from '../types/webviewToExtensionTypes';
import type { WebviewApi } from 'vscode-webview';

const vscode: WebviewApi<never> = acquireVsCodeApi();

export interface AppWebviewApi {
  postMessage(message: ValidWebviewMessage): void;
}

export default {
  postMessage(message) {
    vscode.postMessage(message);
  },
} satisfies AppWebviewApi as AppWebviewApi;
// src/webview/pages/data/login.ts

import { json, redirect } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import Login from '../components/Login';
import type { JsonType } from '../../routes/types';
import type { ActionFunction } from '@remix-run/router';

const action: ActionFunction = async ({ request }) => {
  const { email, password } = Object.fromEntries<FormDataEntryValue>(await request.formData());

  if (!!(email && typeof email !== 'string') || !!(password && typeof password !== 'string')) {
    // should not happen
    throw new Error('Unexpected type');
  }

  const result = await store.dispatch(webviewToExtensionApi.endpoints.login.initiate({ email, password }));
  if ('error' in result) {
    return json<JsonType<'login'>>({ login: result });
  } else {
    return redirect('/chat');
  }
};

export default {
  Component: Login,
  action,
};
// src/webviewProvider/Webview.tsx

import path from 'path';
import { renderToStaticMarkup } from 'react-dom/server';
import { Uri } from 'vscode';

import type { Webview, ExtensionContext } from 'vscode';

export interface WebviewProps {
    context: ExtensionContext,
    webview: Webview,
}

export default function Webview({ context, webview }: WebviewProps) {
    const iconPath = Uri.file(path.join(context.extensionPath, 'resources', 'old_extensionIcon.png'));
    const iconUri = webview.asWebviewUri(iconPath);
    const jsEntry = Uri.joinPath(context.extensionUri, 'dist', 'main.webview.js');
    const jsVendor = Uri.joinPath(context.extensionUri, 'dist', 'vendor.webview.js');
    const webpackRuntime = Uri.joinPath(context.extensionUri, 'dist', 'runtime.webview.js');
    const stylesheet = Uri.joinPath(context.extensionUri, 'dist', 'main.webview.css');

    return (
        <html lang="en">
        <head>
            <meta charSet="UTF-8" />
// src/webview/pages/components/TryWithoutAccount.tsx

import { Spinner } from '@nextui-org/react';
import { useEffect, useRef } from 'react';
import { useNavigation, useSubmit } from 'react-router-dom';
import { useAppActionData } from '../../hooks';

export default function TryWithoutAccount() {
  const firstLoad = useRef<boolean>(true);
  const data = useAppActionData<'loginWithPlaceholder'>()?.loginWithPlaceholder;
  const navigation = useNavigation();

  const submit = useSubmit();
  useEffect(() => {
    if (firstLoad.current) {
      // prevent the 2nd effect triggered by React strict mode from calling submit
      firstLoad.current = false;
      submit(null, { method: 'POST', replace: true });
    }
  }, []);

  return (
    <div className="flex h-full px-6">
      {navigation.state !== 'idle' && <Spinner label="Loading" className="mx-auto" />}
      {(data && 'error' in data) && (
        <div className="text-danger">{data.error?.message}</div>
      )}
    </div>
  );
}
// src/helpers/jaccardDistance.ts

export function jaccardDistance(code1:string, code2:string) {
    // Split the code into arrays of unique words
    let code1Words = new Set(code1.split(/\W+/));
    let code2Words = new Set(code2.split(/\W+/));

    // Calculate the intersection of the two sets
    let intersection = new Set([...code1Words].filter(word => code2Words.has(word)));

    // Calculate the union of the two sets
    let union = new Set([...code1Words, ...code2Words]);

    // Calculate the Jaccard coefficient
    let jaccardCoefficient = intersection.size / union.size;

    // Calculate the Jaccard distance
    let jaccardDistance = 1 - jaccardCoefficient;

    return jaccardDistance;
}
// src/webview/pages/components/FileTree.tsx

import { Checkbox, Accordion, AccordionItem, CheckboxGroup } from '@nextui-org/react';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import { createContext, useContext, useEffect, useState } from 'react';
import { stringify } from 'querystring';
import { FileTreeNode } from '../../../types/types';

interface FileTreeProps {
  node: FileTreeNode;
  isRoot: boolean;
  onCheckboxChange: (node: FileTreeNode, selected: boolean) => void;
}

export const FileTree: React.FC<FileTreeProps> = ({ node, isRoot, onCheckboxChange }) => {

  const handleCheckboxChange = (event: any, node: FileTreeNode) => {
    const selected = event.target.checked;
    onCheckboxChange(node, selected);
  }

  if (node.isFile) {
    return (
      <Checkbox value={node.path} key={node.path} isSelected={node.selected} onChange={(event) => handleCheckboxChange(event, node)}>
        {node.name}
      </Checkbox>
    );
  }

  //Else, this is a folder
  return (
    isRoot ?
// src/webview/pages/data/chatLayout.ts

import { json } from 'react-router-dom';
import { webviewToExtensionApi } from '../../redux/webviewToExtensionApi';
import { store } from '../../redux/store';
import ChatLayout from '../components/ChatLayout';
import type { JsonType } from '../../routes/types';
import type { LoaderFunction } from 'react-router-dom';

const loader: LoaderFunction = async () => {
  const messageListPromise = store.dispatch(webviewToExtensionApi.endpoints.getMessageHistoryList.initiate());
  const result = await messageListPromise;
  messageListPromise.unsubscribe();

  const { data, error } = result;
  return json<JsonType<'getMessageHistoryList'>>({ getMessageHistoryList: { data, error } });
};

export default {
  Component: ChatLayout,
  loader,
};
// src/webview/pages/components/HoverToolTip.tsx

import { Tooltip } from "@nextui-org/react";
import { ReactNode } from "react";

interface HoverTooltipProps {
    children: ReactNode;
    content: string;
    [x: string]: any; // for other props
}

export const HoverTooltip = ({ children, content, ...props }: HoverTooltipProps) => {
  const globalCloseDelay = 100; // Set your global close delay here

  return (
    <Tooltip radius="sm" content={content} placement="bottom-end" closeDelay={globalCloseDelay} {...props}>
      {children}
    </Tooltip>
  );
};
// src/webview/routes/types.ts

import type { ExtensionToWebviewMessage } from '../../types/webviewToExtensionTypes';
import type { ExtensionApiEndpoint, webviewToExtensionApi } from '../redux/webviewToExtensionApi';
import type { SerializedError } from '@reduxjs/toolkit';

export interface DataOrError<T extends ExtensionApiEndpoint> {
  data?: Partial<(typeof webviewToExtensionApi.endpoints)[T]['Types']['ResultType']>;
  error?: ExtensionToWebviewMessage['error'] | SerializedError;
}

export type JsonType<T extends ExtensionApiEndpoint> = {
  [endpoint in T]?: DataOrError<T>;
};
// src/helpers/fileNodeUtils.ts

import * as vscode from 'vscode';
import type { FileTreeNode } from '../types/types';


export function createFileNode(filePath: string, selected: boolean, parentPath: string = ''): FileTreeNode {
		return {
			name: filePath,
			path: parentPath ? `${parentPath}/${filePath}` : filePath,
			children: [],
			selected: selected,
		};
	}

export function addAllFilesToNodeSelectedMap(allFiles: vscode.Uri[], nodeSelectedMap: Map<string, boolean>) {

    for (const file of allFiles){
        let filePath = file.path;
        if (file.path.at(0) == '/')
            filePath = filePath.substring(1);
        nodeSelectedMap.set(filePath, true);
    }
    return nodeSelectedMap;
}

export function processFilesToNestedStructure(files: vscode.Uri[], nodeSelectedMap: Map<string, boolean>) {
// src/webview/components/ExternalLink.tsx

import { useMemo } from 'react';
import { CommandLink } from './';
import type { ReactNode } from 'react';

export interface ExternalLinkProps {
  url: URL;
  children?: ReactNode;
}

export default function ExternalLink({ url, children }: ExternalLinkProps) {
  const args = useMemo(() => ({
    scheme: url.protocol.substring(0, url.protocol.length - 1),
    authority: url.host,
    path: url.pathname,
    ...(url.search.length ? { query: url.search } : {}),
    ...(url.hash.length ? { fragment: url.hash } : {}),
  }), [url]);

  return (
    <CommandLink showAnchorIcon command="vscode.open" args={args}>
      {children}
    </CommandLink>
  );
}
// src/helpers/fileNodeUtils.ts

export function processFilesToNestedStructure(files: vscode.Uri[], nodeSelectedMap: Map<string, boolean>) {
    let root = createFileNode('', false);

    for (const file of files) {
        let current = root;
        const filePathComponents = file.path.split('/');

        for (const [index, component] of filePathComponents.entries()) {
        let childNode = current.children.find((child: any) => child.name === component);

        if (!childNode) {
            let selected = false;
            if (nodeSelectedMap.has(`${current.path}/${component}`)) {
                selected = true;
            }
            childNode = createFileNode(component, selected, current.path);
            current.children.push(childNode);
        }

        if (index === filePathComponents.length - 1) {
            childNode.isFile = true;
        }

        current = childNode;
        }
    }

    return root.children;
}

export function countSelectedFiles(fileNode: any): number {
// src/webview/hooks/redux.ts

import { useDispatch, useSelector } from 'react-redux';
import { useActionData, useLoaderData, useRouteLoaderData } from 'react-router-dom';
import type { ExtensionApiEndpoint } from '../redux/webviewToExtensionApi';
import type { AppDispatch, RootState } from '../redux/store';
import type { JsonType } from '../routes/types';
import type { TypedUseSelectorHook } from 'react-redux';

export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export const useAppActionData = useActionData as <T extends ExtensionApiEndpoint>() =>
  | JsonType<T>
  | null
  | undefined;

export const useAppLoaderData = useLoaderData as <T extends ExtensionApiEndpoint>() =>
  | JsonType<T>
  | null
  | undefined;

export const useAppRouteLoaderData = useRouteLoaderData as <T extends ExtensionApiEndpoint>(routeId: string) =>
  | JsonType<T>
  | null
  | undefined;
// src/helpers/fileNodeUtils.ts

export function countSelectedFiles(fileNode: any): number {
    let count = 0;

    if (fileNode.children && fileNode.children.length > 0) {
        for (const child of fileNode.children) {
            count += countSelectedFiles(child);
        }
    } else {
        count = 1;
    }

    return count;
}

// Helper function to collect all file nodes
export function collectFileNodes(fileNodes: any[]): any[] {
    let collectedNodes: any[] = [];

    for (const fileNode of fileNodes) {
        // If the fileNode has children, call collectFileNodes recursively
        if (fileNode.children && fileNode.children.length > 0) {
            collectedNodes.push(...collectFileNodes(fileNode.children));
        } else {
            collectedNodes.push(fileNode);
        }
    }

    return collectedNodes;
}
